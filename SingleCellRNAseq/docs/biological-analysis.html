<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Analysis of single cell RNA-seq data</title>
  <meta name="description" content="Analysis of single cell RNA-seq data">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Analysis of single cell RNA-seq data" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Analysis of single cell RNA-seq data" />
  
  
  

<meta name="author" content="Vladimir Kiselev (wikiselev), Tallulah Andrews, Jennifer Westoby (Jenni_Westoby), Davis McCarthy (davisjmcc), Maren Büttner (marenbuettner) and Martin Hemberg (m_hemberg)">


<meta name="date" content="2018-05-29">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="cleaning-the-expression-matrix.html">
<link rel="next" href="seurat-chapter.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- for Facebook -->  
<meta property="og:url" content="http://hemberg-lab.github.io/scRNA.seq.course/" />
<meta property="og:description" content="In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data." />
<meta property="og:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- for Twitter -->          
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Analysis of single-cell RNA-seq data" />
<meta name="twitter:description" content="In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data." />
<meta name="twitter:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71525309-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="index.html">Table of Contents</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> About the course</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#video"><i class="fa fa-check"></i><b>1.1</b> Video</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#registration"><i class="fa fa-check"></i><b>1.2</b> Registration</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#github"><i class="fa fa-check"></i><b>1.3</b> GitHub</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#docker-image-rstudio"><i class="fa fa-check"></i><b>1.4</b> Docker image (RStudio)</a></li>
<li class="chapter" data-level="1.5" data-path="index.html"><a href="index.html#manual-installation"><i class="fa fa-check"></i><b>1.5</b> Manual installation</a></li>
<li class="chapter" data-level="1.6" data-path="index.html"><a href="index.html#license"><i class="fa fa-check"></i><b>1.6</b> License</a></li>
<li class="chapter" data-level="1.7" data-path="index.html"><a href="index.html#prerequisites"><i class="fa fa-check"></i><b>1.7</b> Prerequisites</a></li>
<li class="chapter" data-level="1.8" data-path="index.html"><a href="index.html#contact"><i class="fa fa-check"></i><b>1.8</b> Contact</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html"><i class="fa fa-check"></i><b>2</b> Introduction to single-cell RNA-seq</a><ul>
<li class="chapter" data-level="2.1" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#bulk-rna-seq"><i class="fa fa-check"></i><b>2.1</b> Bulk RNA-seq</a></li>
<li class="chapter" data-level="2.2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#scrna-seq"><i class="fa fa-check"></i><b>2.2</b> scRNA-seq</a></li>
<li class="chapter" data-level="2.3" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#workflow"><i class="fa fa-check"></i><b>2.3</b> Workflow</a></li>
<li class="chapter" data-level="2.4" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#computational-analysis"><i class="fa fa-check"></i><b>2.4</b> Computational Analysis</a></li>
<li class="chapter" data-level="2.5" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#challenges"><i class="fa fa-check"></i><b>2.5</b> Challenges</a></li>
<li class="chapter" data-level="2.6" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#experimental-methods"><i class="fa fa-check"></i><b>2.6</b> Experimental methods</a></li>
<li class="chapter" data-level="2.7" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#what-platform-to-use-for-my-experiment"><i class="fa fa-check"></i><b>2.7</b> What platform to use for my experiment?</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html"><i class="fa fa-check"></i><b>3</b> Processing Raw scRNA-seq Data</a><ul>
<li class="chapter" data-level="3.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#fastqc"><i class="fa fa-check"></i><b>3.1</b> FastQC</a><ul>
<li class="chapter" data-level="3.1.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#solution-and-downloading-the-report"><i class="fa fa-check"></i><b>3.1.1</b> Solution and Downloading the Report</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#trimming-reads"><i class="fa fa-check"></i><b>3.2</b> Trimming Reads</a><ul>
<li class="chapter" data-level="3.2.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#solution"><i class="fa fa-check"></i><b>3.2.1</b> Solution</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#file-formats"><i class="fa fa-check"></i><b>3.3</b> File formats</a><ul>
<li class="chapter" data-level="3.3.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#fastq"><i class="fa fa-check"></i><b>3.3.1</b> FastQ</a></li>
<li class="chapter" data-level="3.3.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#bam"><i class="fa fa-check"></i><b>3.3.2</b> BAM</a></li>
<li class="chapter" data-level="3.3.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#cram"><i class="fa fa-check"></i><b>3.3.3</b> CRAM</a></li>
<li class="chapter" data-level="3.3.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#mannually-inspecting-files"><i class="fa fa-check"></i><b>3.3.4</b> Mannually Inspecting files</a></li>
<li class="chapter" data-level="3.3.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#genome-fasta-gtf"><i class="fa fa-check"></i><b>3.3.5</b> Genome (FASTA, GTF)</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#demultiplexing"><i class="fa fa-check"></i><b>3.4</b> Demultiplexing</a><ul>
<li class="chapter" data-level="3.4.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#identifying-cell-containing-dropletsmicrowells"><i class="fa fa-check"></i><b>3.4.1</b> Identifying cell-containing droplets/microwells</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#using-star-to-align-reads"><i class="fa fa-check"></i><b>3.5</b> Using STAR to Align Reads</a><ul>
<li class="chapter" data-level="3.5.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#solution-for-star-alignment"><i class="fa fa-check"></i><b>3.5.1</b> Solution for STAR Alignment</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallisto-and-pseudo-alignment"><i class="fa fa-check"></i><b>3.6</b> Kallisto and Pseudo-Alignment</a><ul>
<li class="chapter" data-level="3.6.1" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#what-is-a-k-mer"><i class="fa fa-check"></i><b>3.6.1</b> What is a k-mer?</a></li>
<li class="chapter" data-level="3.6.2" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#why-map-k-mers-rather-than-reads"><i class="fa fa-check"></i><b>3.6.2</b> Why map k-mers rather than reads?</a></li>
<li class="chapter" data-level="3.6.3" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#kallistos-pseudo-mode"><i class="fa fa-check"></i><b>3.6.3</b> Kallisto’s pseudo mode</a></li>
<li class="chapter" data-level="3.6.4" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#solution-to-kallisto-pseudo-alignment"><i class="fa fa-check"></i><b>3.6.4</b> Solution to Kallisto Pseudo-Alignment</a></li>
<li class="chapter" data-level="3.6.5" data-path="processing-raw-scrna-seq-data.html"><a href="processing-raw-scrna-seq-data.html#understanding-the-output-of-kallisto-pseudo-alignment"><i class="fa fa-check"></i><b>3.6.5</b> Understanding the Output of Kallisto Pseudo-Alignment</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html"><i class="fa fa-check"></i><b>4</b> Construction of expression matrix</a><ul>
<li class="chapter" data-level="4.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-qc"><i class="fa fa-check"></i><b>4.1</b> Reads QC</a></li>
<li class="chapter" data-level="4.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-alignment"><i class="fa fa-check"></i><b>4.2</b> Reads alignment</a></li>
<li class="chapter" data-level="4.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#alignment-example"><i class="fa fa-check"></i><b>4.3</b> Alignment example</a></li>
<li class="chapter" data-level="4.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mapping-qc"><i class="fa fa-check"></i><b>4.4</b> Mapping QC</a></li>
<li class="chapter" data-level="4.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-quantification"><i class="fa fa-check"></i><b>4.5</b> Reads quantification</a></li>
<li class="chapter" data-level="4.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#umichapter"><i class="fa fa-check"></i><b>4.6</b> Unique Molecular Identifiers (UMIs)</a><ul>
<li class="chapter" data-level="4.6.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction"><i class="fa fa-check"></i><b>4.6.1</b> Introduction</a></li>
<li class="chapter" data-level="4.6.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mapping-barcodes"><i class="fa fa-check"></i><b>4.6.2</b> Mapping Barcodes</a></li>
<li class="chapter" data-level="4.6.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#counting-barcodes"><i class="fa fa-check"></i><b>4.6.3</b> Counting Barcodes</a></li>
<li class="chapter" data-level="4.6.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#correcting-for-errors"><i class="fa fa-check"></i><b>4.6.4</b> Correcting for Errors</a></li>
<li class="chapter" data-level="4.6.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#downstream-analysis"><i class="fa fa-check"></i><b>4.6.5</b> Downstream Analysis</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html"><i class="fa fa-check"></i><b>5</b> Introduction to R/Bioconductor</a><ul>
<li class="chapter" data-level="5.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#installing-packages"><i class="fa fa-check"></i><b>5.1</b> Installing packages</a><ul>
<li class="chapter" data-level="5.1.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#cran"><i class="fa fa-check"></i><b>5.1.1</b> CRAN</a></li>
<li class="chapter" data-level="5.1.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#github-1"><i class="fa fa-check"></i><b>5.1.2</b> Github</a></li>
<li class="chapter" data-level="5.1.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#bioconductor"><i class="fa fa-check"></i><b>5.1.3</b> Bioconductor</a></li>
<li class="chapter" data-level="5.1.4" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#source"><i class="fa fa-check"></i><b>5.1.4</b> Source</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#installation-instructions"><i class="fa fa-check"></i><b>5.2</b> Installation instructions:</a></li>
<li class="chapter" data-level="5.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#data-typesclasses"><i class="fa fa-check"></i><b>5.3</b> Data-types/classes</a><ul>
<li class="chapter" data-level="5.3.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#numeric"><i class="fa fa-check"></i><b>5.3.1</b> Numeric</a></li>
<li class="chapter" data-level="5.3.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#characterstring"><i class="fa fa-check"></i><b>5.3.2</b> Character/String</a></li>
<li class="chapter" data-level="5.3.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#logical"><i class="fa fa-check"></i><b>5.3.3</b> Logical</a></li>
<li class="chapter" data-level="5.3.4" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#factors"><i class="fa fa-check"></i><b>5.3.4</b> Factors</a></li>
<li class="chapter" data-level="5.3.5" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#checking-classtype"><i class="fa fa-check"></i><b>5.3.5</b> Checking class/type</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#basic-data-structures"><i class="fa fa-check"></i><b>5.4</b> Basic data structures</a></li>
<li class="chapter" data-level="5.5" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#more-information"><i class="fa fa-check"></i><b>5.5</b> More information</a></li>
<li class="chapter" data-level="5.6" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#data-types"><i class="fa fa-check"></i><b>5.6</b> Data Types</a><ul>
<li class="chapter" data-level="5.6.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#what-is-tidy-data"><i class="fa fa-check"></i><b>5.6.1</b> What is Tidy Data?</a></li>
<li class="chapter" data-level="5.6.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#what-is-rich-data"><i class="fa fa-check"></i><b>5.6.2</b> What is Rich Data?</a></li>
<li class="chapter" data-level="5.6.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#what-is-bioconductor"><i class="fa fa-check"></i><b>5.6.3</b> What is Bioconductor?</a></li>
<li class="chapter" data-level="5.6.4" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#singlecellexperiment-class"><i class="fa fa-check"></i><b>5.6.4</b> <code>SingleCellExperiment</code> class</a></li>
<li class="chapter" data-level="5.6.5" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#scater-package"><i class="fa fa-check"></i><b>5.6.5</b> <code>scater</code> package</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#bioconductor-singlecellexperiment-and-scater"><i class="fa fa-check"></i><b>5.7</b> Bioconductor, <code>SingleCellExperiment</code> and <code>scater</code></a><ul>
<li class="chapter" data-level="5.7.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#bioconductor-1"><i class="fa fa-check"></i><b>5.7.1</b> Bioconductor</a></li>
<li class="chapter" data-level="5.7.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#singlecellexperiment-class-1"><i class="fa fa-check"></i><b>5.7.2</b> <code>SingleCellExperiment</code> class</a></li>
<li class="chapter" data-level="5.7.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#scater-package-1"><i class="fa fa-check"></i><b>5.7.3</b> <code>scater</code> package</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#an-introduction-to-ggplot2"><i class="fa fa-check"></i><b>5.8</b> An Introduction to ggplot2</a><ul>
<li class="chapter" data-level="5.8.1" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#what-is-ggplot2"><i class="fa fa-check"></i><b>5.8.1</b> What is ggplot2?</a></li>
<li class="chapter" data-level="5.8.2" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#principles-of-ggplot2"><i class="fa fa-check"></i><b>5.8.2</b> Principles of ggplot2</a></li>
<li class="chapter" data-level="5.8.3" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#using-the-aes-mapping-function"><i class="fa fa-check"></i><b>5.8.3</b> Using the <code>aes</code> mapping function</a></li>
<li class="chapter" data-level="5.8.4" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#geoms"><i class="fa fa-check"></i><b>5.8.4</b> Geoms</a></li>
<li class="chapter" data-level="5.8.5" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#plotting-data-from-more-than-2-cells"><i class="fa fa-check"></i><b>5.8.5</b> Plotting data from more than 2 cells</a></li>
<li class="chapter" data-level="5.8.6" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#plotting-heatmaps"><i class="fa fa-check"></i><b>5.8.6</b> Plotting heatmaps</a></li>
<li class="chapter" data-level="5.8.7" data-path="introduction-to-rbioconductor.html"><a href="introduction-to-rbioconductor.html#principle-component-analysis"><i class="fa fa-check"></i><b>5.8.7</b> Principle Component Analysis</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="tabula-muris.html"><a href="tabula-muris.html"><i class="fa fa-check"></i><b>6</b> Tabula Muris</a><ul>
<li class="chapter" data-level="6.1" data-path="tabula-muris.html"><a href="tabula-muris.html#introduction-1"><i class="fa fa-check"></i><b>6.1</b> Introduction</a></li>
<li class="chapter" data-level="6.2" data-path="tabula-muris.html"><a href="tabula-muris.html#downloading-the-data"><i class="fa fa-check"></i><b>6.2</b> Downloading the data</a></li>
<li class="chapter" data-level="6.3" data-path="tabula-muris.html"><a href="tabula-muris.html#reading-the-data-smartseq2"><i class="fa fa-check"></i><b>6.3</b> Reading the data (Smartseq2)</a></li>
<li class="chapter" data-level="6.4" data-path="tabula-muris.html"><a href="tabula-muris.html#building-a-scater-object"><i class="fa fa-check"></i><b>6.4</b> Building a scater object</a></li>
<li class="chapter" data-level="6.5" data-path="tabula-muris.html"><a href="tabula-muris.html#reading-the-data-10x"><i class="fa fa-check"></i><b>6.5</b> Reading the data (10X)</a></li>
<li class="chapter" data-level="6.6" data-path="tabula-muris.html"><a href="tabula-muris.html#building-a-scater-object-1"><i class="fa fa-check"></i><b>6.6</b> Building a scater object</a></li>
<li class="chapter" data-level="6.7" data-path="tabula-muris.html"><a href="tabula-muris.html#advanced-exercise"><i class="fa fa-check"></i><b>6.7</b> Advanced Exercise</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html"><i class="fa fa-check"></i><b>7</b> Cleaning the Expression Matrix</a><ul>
<li class="chapter" data-level="7.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exprs-qc"><i class="fa fa-check"></i><b>7.1</b> Expression QC (UMI)</a><ul>
<li class="chapter" data-level="7.1.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-2"><i class="fa fa-check"></i><b>7.1.1</b> Introduction</a></li>
<li class="chapter" data-level="7.1.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#tung-dataset"><i class="fa fa-check"></i><b>7.1.2</b> Tung dataset</a></li>
<li class="chapter" data-level="7.1.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#cell-qc"><i class="fa fa-check"></i><b>7.1.3</b> Cell QC</a></li>
<li class="chapter" data-level="7.1.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#cell-filtering"><i class="fa fa-check"></i><b>7.1.4</b> Cell filtering</a></li>
<li class="chapter" data-level="7.1.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#compare-filterings"><i class="fa fa-check"></i><b>7.1.5</b> Compare filterings</a></li>
<li class="chapter" data-level="7.1.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#gene-analysis"><i class="fa fa-check"></i><b>7.1.6</b> Gene analysis</a></li>
<li class="chapter" data-level="7.1.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#save-the-data"><i class="fa fa-check"></i><b>7.1.7</b> Save the data</a></li>
<li class="chapter" data-level="7.1.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#big-exercise"><i class="fa fa-check"></i><b>7.1.8</b> Big Exercise</a></li>
<li class="chapter" data-level="7.1.9" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#sessioninfo"><i class="fa fa-check"></i><b>7.1.9</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#expression-qc-reads"><i class="fa fa-check"></i><b>7.2</b> Expression QC (Reads)</a></li>
<li class="chapter" data-level="7.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#data-visualization"><i class="fa fa-check"></i><b>7.3</b> Data visualization</a><ul>
<li class="chapter" data-level="7.3.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-3"><i class="fa fa-check"></i><b>7.3.1</b> Introduction</a></li>
<li class="chapter" data-level="7.3.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#visual-pca"><i class="fa fa-check"></i><b>7.3.2</b> PCA plot</a></li>
<li class="chapter" data-level="7.3.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#visual-tsne"><i class="fa fa-check"></i><b>7.3.3</b> tSNE map</a></li>
<li class="chapter" data-level="7.3.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#big-exercise-1"><i class="fa fa-check"></i><b>7.3.4</b> Big Exercise</a></li>
<li class="chapter" data-level="7.3.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#sessioninfo-1"><i class="fa fa-check"></i><b>7.3.5</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#data-visualization-reads"><i class="fa fa-check"></i><b>7.4</b> Data visualization (Reads)</a></li>
<li class="chapter" data-level="7.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#identifying-confounding-factors"><i class="fa fa-check"></i><b>7.5</b> Identifying confounding factors</a><ul>
<li class="chapter" data-level="7.5.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-4"><i class="fa fa-check"></i><b>7.5.1</b> Introduction</a></li>
<li class="chapter" data-level="7.5.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#correlations-with-pcs"><i class="fa fa-check"></i><b>7.5.2</b> Correlations with PCs</a></li>
<li class="chapter" data-level="7.5.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#explanatory-variables"><i class="fa fa-check"></i><b>7.5.3</b> Explanatory variables</a></li>
<li class="chapter" data-level="7.5.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#other-confounders"><i class="fa fa-check"></i><b>7.5.4</b> Other confounders</a></li>
<li class="chapter" data-level="7.5.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exercise"><i class="fa fa-check"></i><b>7.5.5</b> Exercise</a></li>
<li class="chapter" data-level="7.5.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#sessioninfo-2"><i class="fa fa-check"></i><b>7.5.6</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#identifying-confounding-factors-reads"><i class="fa fa-check"></i><b>7.6</b> Identifying confounding factors (Reads)</a></li>
<li class="chapter" data-level="7.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-theory"><i class="fa fa-check"></i><b>7.7</b> Normalization theory</a><ul>
<li class="chapter" data-level="7.7.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-5"><i class="fa fa-check"></i><b>7.7.1</b> Introduction</a></li>
<li class="chapter" data-level="7.7.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#library-size-1"><i class="fa fa-check"></i><b>7.7.2</b> Library size</a></li>
<li class="chapter" data-level="7.7.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalisations"><i class="fa fa-check"></i><b>7.7.3</b> Normalisations</a></li>
<li class="chapter" data-level="7.7.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#effectiveness"><i class="fa fa-check"></i><b>7.7.4</b> Effectiveness</a></li>
</ul></li>
<li class="chapter" data-level="7.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-practice-umi"><i class="fa fa-check"></i><b>7.8</b> Normalization practice (UMI)</a><ul>
<li class="chapter" data-level="7.8.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#raw"><i class="fa fa-check"></i><b>7.8.1</b> Raw</a></li>
<li class="chapter" data-level="7.8.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#cpm-1"><i class="fa fa-check"></i><b>7.8.2</b> CPM</a></li>
<li class="chapter" data-level="7.8.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#size-factor-rle"><i class="fa fa-check"></i><b>7.8.3</b> Size-factor (RLE)</a></li>
<li class="chapter" data-level="7.8.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#upperquantile"><i class="fa fa-check"></i><b>7.8.4</b> Upperquantile</a></li>
<li class="chapter" data-level="7.8.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#tmm-1"><i class="fa fa-check"></i><b>7.8.5</b> TMM</a></li>
<li class="chapter" data-level="7.8.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#scran-1"><i class="fa fa-check"></i><b>7.8.6</b> scran</a></li>
<li class="chapter" data-level="7.8.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#downsampling-1"><i class="fa fa-check"></i><b>7.8.7</b> Downsampling</a></li>
<li class="chapter" data-level="7.8.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalisation-for-genetranscript-length"><i class="fa fa-check"></i><b>7.8.8</b> Normalisation for gene/transcript length</a></li>
<li class="chapter" data-level="7.8.9" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#exercise-1"><i class="fa fa-check"></i><b>7.8.9</b> Exercise</a></li>
<li class="chapter" data-level="7.8.10" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#sessioninfo-3"><i class="fa fa-check"></i><b>7.8.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="7.9" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#normalization-practice-reads"><i class="fa fa-check"></i><b>7.9</b> Normalization practice (Reads)</a></li>
<li class="chapter" data-level="7.10" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#dealing-with-confounders"><i class="fa fa-check"></i><b>7.10</b> Dealing with confounders</a><ul>
<li class="chapter" data-level="7.10.1" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#introduction-6"><i class="fa fa-check"></i><b>7.10.1</b> Introduction</a></li>
<li class="chapter" data-level="7.10.2" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#remove-unwanted-variation"><i class="fa fa-check"></i><b>7.10.2</b> Remove Unwanted Variation</a></li>
<li class="chapter" data-level="7.10.3" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#combat"><i class="fa fa-check"></i><b>7.10.3</b> Combat</a></li>
<li class="chapter" data-level="7.10.4" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#mnncorrect"><i class="fa fa-check"></i><b>7.10.4</b> mnnCorrect</a></li>
<li class="chapter" data-level="7.10.5" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#glm"><i class="fa fa-check"></i><b>7.10.5</b> GLM</a></li>
<li class="chapter" data-level="7.10.6" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#how-to-evaluate-and-compare-confounder-removal-strategies"><i class="fa fa-check"></i><b>7.10.6</b> How to evaluate and compare confounder removal strategies</a></li>
<li class="chapter" data-level="7.10.7" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#big-exercise-2"><i class="fa fa-check"></i><b>7.10.7</b> Big Exercise</a></li>
<li class="chapter" data-level="7.10.8" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#sessioninfo-4"><i class="fa fa-check"></i><b>7.10.8</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="7.11" data-path="cleaning-the-expression-matrix.html"><a href="cleaning-the-expression-matrix.html#dealing-with-confounders-reads"><i class="fa fa-check"></i><b>7.11</b> Dealing with confounders (Reads)</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="biological-analysis.html"><a href="biological-analysis.html"><i class="fa fa-check"></i><b>8</b> Biological Analysis</a><ul>
<li class="chapter" data-level="8.1" data-path="biological-analysis.html"><a href="biological-analysis.html#clustering-introduction"><i class="fa fa-check"></i><b>8.1</b> Clustering Introduction</a><ul>
<li class="chapter" data-level="8.1.1" data-path="biological-analysis.html"><a href="biological-analysis.html#introduction-7"><i class="fa fa-check"></i><b>8.1.1</b> Introduction</a></li>
<li class="chapter" data-level="8.1.2" data-path="biological-analysis.html"><a href="biological-analysis.html#dimensionality-reductions"><i class="fa fa-check"></i><b>8.1.2</b> Dimensionality reductions</a></li>
<li class="chapter" data-level="8.1.3" data-path="biological-analysis.html"><a href="biological-analysis.html#clustering-methods"><i class="fa fa-check"></i><b>8.1.3</b> Clustering methods</a></li>
<li class="chapter" data-level="8.1.4" data-path="biological-analysis.html"><a href="biological-analysis.html#challenges-in-clustering"><i class="fa fa-check"></i><b>8.1.4</b> Challenges in clustering</a></li>
<li class="chapter" data-level="8.1.5" data-path="biological-analysis.html"><a href="biological-analysis.html#tools-for-scrna-seq-data"><i class="fa fa-check"></i><b>8.1.5</b> Tools for scRNA-seq data</a></li>
<li class="chapter" data-level="8.1.6" data-path="biological-analysis.html"><a href="biological-analysis.html#comparing-clustering"><i class="fa fa-check"></i><b>8.1.6</b> Comparing clustering</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="biological-analysis.html"><a href="biological-analysis.html#clust-methods"><i class="fa fa-check"></i><b>8.2</b> Clustering example</a><ul>
<li class="chapter" data-level="8.2.1" data-path="biological-analysis.html"><a href="biological-analysis.html#deng-dataset"><i class="fa fa-check"></i><b>8.2.1</b> Deng dataset</a></li>
<li class="chapter" data-level="8.2.2" data-path="biological-analysis.html"><a href="biological-analysis.html#sc3-1"><i class="fa fa-check"></i><b>8.2.2</b> SC3</a></li>
<li class="chapter" data-level="8.2.3" data-path="biological-analysis.html"><a href="biological-analysis.html#pcareduce-1"><i class="fa fa-check"></i><b>8.2.3</b> pcaReduce</a></li>
<li class="chapter" data-level="8.2.4" data-path="biological-analysis.html"><a href="biological-analysis.html#tsne-kmeans"><i class="fa fa-check"></i><b>8.2.4</b> tSNE + kmeans</a></li>
<li class="chapter" data-level="8.2.5" data-path="biological-analysis.html"><a href="biological-analysis.html#snn-cliq-1"><i class="fa fa-check"></i><b>8.2.5</b> SNN-Cliq</a></li>
<li class="chapter" data-level="8.2.6" data-path="biological-analysis.html"><a href="biological-analysis.html#sincera-1"><i class="fa fa-check"></i><b>8.2.6</b> SINCERA</a></li>
<li class="chapter" data-level="8.2.7" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-5"><i class="fa fa-check"></i><b>8.2.7</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="biological-analysis.html"><a href="biological-analysis.html#feature-selection"><i class="fa fa-check"></i><b>8.3</b> Feature Selection</a><ul>
<li class="chapter" data-level="8.3.1" data-path="biological-analysis.html"><a href="biological-analysis.html#identifying-genes-vs-a-null-model"><i class="fa fa-check"></i><b>8.3.1</b> Identifying Genes vs a Null Model</a></li>
<li class="chapter" data-level="8.3.2" data-path="biological-analysis.html"><a href="biological-analysis.html#correlated-expression"><i class="fa fa-check"></i><b>8.3.2</b> Correlated Expression</a></li>
<li class="chapter" data-level="8.3.3" data-path="biological-analysis.html"><a href="biological-analysis.html#comparing-methods"><i class="fa fa-check"></i><b>8.3.3</b> Comparing Methods</a></li>
<li class="chapter" data-level="8.3.4" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-6"><i class="fa fa-check"></i><b>8.3.4</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="biological-analysis.html"><a href="biological-analysis.html#pseudotime-analysis"><i class="fa fa-check"></i><b>8.4</b> Pseudotime analysis</a><ul>
<li class="chapter" data-level="8.4.1" data-path="biological-analysis.html"><a href="biological-analysis.html#first-look-at-deng-data"><i class="fa fa-check"></i><b>8.4.1</b> First look at Deng data</a></li>
<li class="chapter" data-level="8.4.2" data-path="biological-analysis.html"><a href="biological-analysis.html#tscan"><i class="fa fa-check"></i><b>8.4.2</b> TSCAN</a></li>
<li class="chapter" data-level="8.4.3" data-path="biological-analysis.html"><a href="biological-analysis.html#monocle"><i class="fa fa-check"></i><b>8.4.3</b> monocle</a></li>
<li class="chapter" data-level="8.4.4" data-path="biological-analysis.html"><a href="biological-analysis.html#diffusion-maps"><i class="fa fa-check"></i><b>8.4.4</b> Diffusion maps</a></li>
<li class="chapter" data-level="8.4.5" data-path="biological-analysis.html"><a href="biological-analysis.html#slicer"><i class="fa fa-check"></i><b>8.4.5</b> SLICER</a></li>
<li class="chapter" data-level="8.4.6" data-path="biological-analysis.html"><a href="biological-analysis.html#ouija"><i class="fa fa-check"></i><b>8.4.6</b> Ouija</a></li>
<li class="chapter" data-level="8.4.7" data-path="biological-analysis.html"><a href="biological-analysis.html#comparison-of-the-methods"><i class="fa fa-check"></i><b>8.4.7</b> Comparison of the methods</a></li>
<li class="chapter" data-level="8.4.8" data-path="biological-analysis.html"><a href="biological-analysis.html#expression-of-genes-through-time"><i class="fa fa-check"></i><b>8.4.8</b> Expression of genes through time</a></li>
<li class="chapter" data-level="8.4.9" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-7"><i class="fa fa-check"></i><b>8.4.9</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.5" data-path="biological-analysis.html"><a href="biological-analysis.html#imputation"><i class="fa fa-check"></i><b>8.5</b> Imputation</a><ul>
<li class="chapter" data-level="8.5.1" data-path="biological-analysis.html"><a href="biological-analysis.html#scimpute"><i class="fa fa-check"></i><b>8.5.1</b> scImpute</a></li>
<li class="chapter" data-level="8.5.2" data-path="biological-analysis.html"><a href="biological-analysis.html#magic"><i class="fa fa-check"></i><b>8.5.2</b> MAGIC</a></li>
<li class="chapter" data-level="8.5.3" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-8"><i class="fa fa-check"></i><b>8.5.3</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.6" data-path="biological-analysis.html"><a href="biological-analysis.html#dechapter"><i class="fa fa-check"></i><b>8.6</b> Differential Expression (DE) analysis</a><ul>
<li class="chapter" data-level="8.6.1" data-path="biological-analysis.html"><a href="biological-analysis.html#bulk-rna-seq-1"><i class="fa fa-check"></i><b>8.6.1</b> Bulk RNA-seq</a></li>
<li class="chapter" data-level="8.6.2" data-path="biological-analysis.html"><a href="biological-analysis.html#single-cell-rna-seq"><i class="fa fa-check"></i><b>8.6.2</b> Single cell RNA-seq</a></li>
<li class="chapter" data-level="8.6.3" data-path="biological-analysis.html"><a href="biological-analysis.html#differences-in-distribution"><i class="fa fa-check"></i><b>8.6.3</b> Differences in Distribution</a></li>
<li class="chapter" data-level="8.6.4" data-path="biological-analysis.html"><a href="biological-analysis.html#models-of-single-cell-rnaseq-data"><i class="fa fa-check"></i><b>8.6.4</b> Models of single-cell RNASeq data</a></li>
</ul></li>
<li class="chapter" data-level="8.7" data-path="biological-analysis.html"><a href="biological-analysis.html#de-in-a-real-dataset"><i class="fa fa-check"></i><b>8.7</b> DE in a real dataset</a><ul>
<li class="chapter" data-level="8.7.1" data-path="biological-analysis.html"><a href="biological-analysis.html#introduction-8"><i class="fa fa-check"></i><b>8.7.1</b> Introduction</a></li>
<li class="chapter" data-level="8.7.2" data-path="biological-analysis.html"><a href="biological-analysis.html#kolmogorov-smirnov-test"><i class="fa fa-check"></i><b>8.7.2</b> Kolmogorov-Smirnov test</a></li>
<li class="chapter" data-level="8.7.3" data-path="biological-analysis.html"><a href="biological-analysis.html#wilcoxmann-whitney-u-test"><i class="fa fa-check"></i><b>8.7.3</b> Wilcox/Mann-Whitney-U Test</a></li>
<li class="chapter" data-level="8.7.4" data-path="biological-analysis.html"><a href="biological-analysis.html#edger"><i class="fa fa-check"></i><b>8.7.4</b> edgeR</a></li>
<li class="chapter" data-level="8.7.5" data-path="biological-analysis.html"><a href="biological-analysis.html#monocle-1"><i class="fa fa-check"></i><b>8.7.5</b> Monocle</a></li>
<li class="chapter" data-level="8.7.6" data-path="biological-analysis.html"><a href="biological-analysis.html#mast"><i class="fa fa-check"></i><b>8.7.6</b> MAST</a></li>
<li class="chapter" data-level="8.7.7" data-path="biological-analysis.html"><a href="biological-analysis.html#slow-methods-1h-to-run"><i class="fa fa-check"></i><b>8.7.7</b> Slow Methods (&gt;1h to run)</a></li>
<li class="chapter" data-level="8.7.8" data-path="biological-analysis.html"><a href="biological-analysis.html#bpsc"><i class="fa fa-check"></i><b>8.7.8</b> BPSC</a></li>
<li class="chapter" data-level="8.7.9" data-path="biological-analysis.html"><a href="biological-analysis.html#scde"><i class="fa fa-check"></i><b>8.7.9</b> SCDE</a></li>
<li class="chapter" data-level="8.7.10" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-9"><i class="fa fa-check"></i><b>8.7.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.8" data-path="biological-analysis.html"><a href="biological-analysis.html#comparingcombining-scrnaseq-datasets"><i class="fa fa-check"></i><b>8.8</b> Comparing/Combining scRNASeq datasets</a><ul>
<li class="chapter" data-level="8.8.1" data-path="biological-analysis.html"><a href="biological-analysis.html#introduction-9"><i class="fa fa-check"></i><b>8.8.1</b> Introduction</a></li>
<li class="chapter" data-level="8.8.2" data-path="biological-analysis.html"><a href="biological-analysis.html#datasets"><i class="fa fa-check"></i><b>8.8.2</b> Datasets</a></li>
<li class="chapter" data-level="8.8.3" data-path="biological-analysis.html"><a href="biological-analysis.html#projecting-cells-onto-annotated-cell-types-scmap"><i class="fa fa-check"></i><b>8.8.3</b> Projecting cells onto annotated cell-types (scmap)</a></li>
<li class="chapter" data-level="8.8.4" data-path="biological-analysis.html"><a href="biological-analysis.html#cell-to-cell-mapping"><i class="fa fa-check"></i><b>8.8.4</b> Cell-to-Cell mapping</a></li>
<li class="chapter" data-level="8.8.5" data-path="biological-analysis.html"><a href="biological-analysis.html#metaneighbour"><i class="fa fa-check"></i><b>8.8.5</b> Metaneighbour</a></li>
<li class="chapter" data-level="8.8.6" data-path="biological-analysis.html"><a href="biological-analysis.html#mnncorrect-1"><i class="fa fa-check"></i><b>8.8.6</b> mnnCorrect</a></li>
<li class="chapter" data-level="8.8.7" data-path="biological-analysis.html"><a href="biological-analysis.html#cannonical-correlation-analysis-seurat"><i class="fa fa-check"></i><b>8.8.7</b> Cannonical Correlation Analysis (Seurat)</a></li>
<li class="chapter" data-level="8.8.8" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-10"><i class="fa fa-check"></i><b>8.8.8</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="8.9" data-path="biological-analysis.html"><a href="biological-analysis.html#search-scrna-seq-data"><i class="fa fa-check"></i><b>8.9</b> Search scRNA-Seq data</a><ul>
<li class="chapter" data-level="8.9.1" data-path="biological-analysis.html"><a href="biological-analysis.html#about"><i class="fa fa-check"></i><b>8.9.1</b> About</a></li>
<li class="chapter" data-level="8.9.2" data-path="biological-analysis.html"><a href="biological-analysis.html#dataset"><i class="fa fa-check"></i><b>8.9.2</b> Dataset</a></li>
<li class="chapter" data-level="8.9.3" data-path="biological-analysis.html"><a href="biological-analysis.html#gene-index"><i class="fa fa-check"></i><b>8.9.3</b> Gene Index</a></li>
<li class="chapter" data-level="8.9.4" data-path="biological-analysis.html"><a href="biological-analysis.html#marker-genes"><i class="fa fa-check"></i><b>8.9.4</b> Marker genes</a></li>
<li class="chapter" data-level="8.9.5" data-path="biological-analysis.html"><a href="biological-analysis.html#search-cells-by-a-gene-list"><i class="fa fa-check"></i><b>8.9.5</b> Search cells by a gene list</a></li>
<li class="chapter" data-level="8.9.6" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-11"><i class="fa fa-check"></i><b>8.9.6</b> sessionInfo()</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="seurat-chapter.html"><a href="seurat-chapter.html"><i class="fa fa-check"></i><b>9</b> Seurat</a><ul>
<li class="chapter" data-level="9.1" data-path="seurat-chapter.html"><a href="seurat-chapter.html#seurat-object-class"><i class="fa fa-check"></i><b>9.1</b> <code>Seurat</code> object class</a></li>
<li class="chapter" data-level="9.2" data-path="seurat-chapter.html"><a href="seurat-chapter.html#expression-qc"><i class="fa fa-check"></i><b>9.2</b> Expression QC</a></li>
<li class="chapter" data-level="9.3" data-path="seurat-chapter.html"><a href="seurat-chapter.html#normalization"><i class="fa fa-check"></i><b>9.3</b> Normalization</a></li>
<li class="chapter" data-level="9.4" data-path="seurat-chapter.html"><a href="seurat-chapter.html#highly-variable-genes-1"><i class="fa fa-check"></i><b>9.4</b> Highly variable genes</a></li>
<li class="chapter" data-level="9.5" data-path="seurat-chapter.html"><a href="seurat-chapter.html#dealing-with-confounders-1"><i class="fa fa-check"></i><b>9.5</b> Dealing with confounders</a></li>
<li class="chapter" data-level="9.6" data-path="seurat-chapter.html"><a href="seurat-chapter.html#linear-dimensionality-reduction"><i class="fa fa-check"></i><b>9.6</b> Linear dimensionality reduction</a></li>
<li class="chapter" data-level="9.7" data-path="seurat-chapter.html"><a href="seurat-chapter.html#significant-pcs"><i class="fa fa-check"></i><b>9.7</b> Significant PCs</a></li>
<li class="chapter" data-level="9.8" data-path="seurat-chapter.html"><a href="seurat-chapter.html#clustering-cells"><i class="fa fa-check"></i><b>9.8</b> Clustering cells</a></li>
<li class="chapter" data-level="9.9" data-path="seurat-chapter.html"><a href="seurat-chapter.html#marker-genes-1"><i class="fa fa-check"></i><b>9.9</b> Marker genes</a></li>
<li class="chapter" data-level="9.10" data-path="seurat-chapter.html"><a href="seurat-chapter.html#sessioninfo-12"><i class="fa fa-check"></i><b>9.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><i class="fa fa-check"></i><b>10</b> “Ideal” scRNAseq pipeline (as of Oct 2017)</a><ul>
<li class="chapter" data-level="10.1" data-path="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-oct-2017.html#experimental-design"><i class="fa fa-check"></i><b>10.1</b> Experimental Design</a></li>
<li class="chapter" data-level="10.2" data-path="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-oct-2017.html#processing-reads"><i class="fa fa-check"></i><b>10.2</b> Processing Reads</a></li>
<li class="chapter" data-level="10.3" data-path="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-oct-2017.html#preparing-expression-matrix"><i class="fa fa-check"></i><b>10.3</b> Preparing Expression Matrix</a></li>
<li class="chapter" data-level="10.4" data-path="ideal-scrnaseq-pipeline-as-of-oct-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-oct-2017.html#biological-interpretation"><i class="fa fa-check"></i><b>10.4</b> Biological Interpretation</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="advanced-exercises.html"><a href="advanced-exercises.html"><i class="fa fa-check"></i><b>11</b> Advanced exercises</a></li>
<li class="chapter" data-level="12" data-path="resources.html"><a href="resources.html"><i class="fa fa-check"></i><b>12</b> Resources</a><ul>
<li class="chapter" data-level="12.1" data-path="resources.html"><a href="resources.html#scrna-seq-protocols"><i class="fa fa-check"></i><b>12.1</b> scRNA-seq protocols</a></li>
<li class="chapter" data-level="12.2" data-path="resources.html"><a href="resources.html#external-rna-control-consortium-ercc"><i class="fa fa-check"></i><b>12.2</b> External RNA Control Consortium (ERCC)</a></li>
<li class="chapter" data-level="12.3" data-path="resources.html"><a href="resources.html#scrna-seq-analysis-tools"><i class="fa fa-check"></i><b>12.3</b> scRNA-seq analysis tools</a></li>
<li class="chapter" data-level="12.4" data-path="resources.html"><a href="resources.html#scrna-seq-public-datasets"><i class="fa fa-check"></i><b>12.4</b> scRNA-seq public datasets</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>13</b> References</a></li>
<li class="divider"></li>
<li><a href="http://www.sanger.ac.uk/science/groups/hemberg-group" target="blank">Hemberg Lab</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Analysis of single cell RNA-seq data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="biological-analysis" class="section level1">
<h1><span class="header-section-number">8</span> Biological Analysis</h1>
<div id="clustering-introduction" class="section level2">
<h2><span class="header-section-number">8.1</span> Clustering Introduction</h2>
<p>Once we have normalized the data and removed confounders we can carry out analyses that are relevant to the biological questions at hand. The exact nature of the analysis depends on the dataset. Nevertheless, there are a few aspects that are useful in a wide range of contexts and we will be discussing some of them in the next few chapters. We will start with the clustering of scRNA-seq data.</p>
<div id="introduction-7" class="section level3">
<h3><span class="header-section-number">8.1.1</span> Introduction</h3>
<p>One of the most promising applications of scRNA-seq is <em>de novo</em> discovery and annotation of cell-types based on transcription profiles. Computationally, this is a hard problem as it amounts to <strong>unsupervised clustering</strong>. That is, we need to identify groups of cells based on the similarities of the transcriptomes without any prior knowledge of the labels. Moreover, in most situations we do not even know the number of clusters <em>a priori</em>. The problem is made even more challenging due to the high level of noise (both technical and biological) and the large number of dimensions (i.e. genes).</p>
</div>
<div id="dimensionality-reductions" class="section level3">
<h3><span class="header-section-number">8.1.2</span> Dimensionality reductions</h3>
<p>When working with large datasets, it can often be beneficial to apply some sort of dimensionality reduction method. By projecting the data onto a lower-dimensional sub-space, one is often able to significantly reduce the amount of noise. An additional benefit is that it is typically much easier to visualize the data in a 2 or 3-dimensional subspace. We have already discussed PCA (chapter <a href="cleaning-the-expression-matrix.html#visual-pca">7.3.2</a>) and t-SNE (chapter <a href="cleaning-the-expression-matrix.html#visual-pca">7.3.2</a>).</p>
</div>
<div id="clustering-methods" class="section level3">
<h3><span class="header-section-number">8.1.3</span> Clustering methods</h3>
<p><strong>Unsupervised clustering</strong> is useful in many different applications and it has been widely studied in machine learning. Some of the most popular approaches are <strong>hierarchical clustering</strong>, <strong>k-means clustering</strong> and <strong>graph-based clustering</strong>.</p>
<div id="hierarchical-clustering" class="section level4">
<h4><span class="header-section-number">8.1.3.1</span> Hierarchical clustering</h4>
<p>In <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering">hierarchical clustering</a>, one can use either a bottom-up or a top-down approach. In the former case, each cell is initially assigned to its own cluster and pairs of clusters are subsequently merged to create a hieararchy:</p>
<div class="figure" style="text-align: center"><span id="fig:clust-hierarch-raw"></span>
<img src="figures/hierarchical_clustering1.png" alt="Raw data" width="30%" />
<p class="caption">
Figure 8.1: Raw data
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:clust-hierarch-dendr"></span>
<img src="figures/hierarchical_clustering2.png" alt="The hierarchical clustering dendrogram" width="50%" />
<p class="caption">
Figure 8.2: The hierarchical clustering dendrogram
</p>
</div>
<p>With a top-down strategy, one instead starts with all observations in one cluster and then recursively split each cluster to form a hierarchy. One of the advantages of this strategy is that the method is deterministic.</p>
</div>
<div id="k-means" class="section level4">
<h4><span class="header-section-number">8.1.3.2</span> k-means</h4>
<p>In <a href="https://en.wikipedia.org/wiki/K-means_clustering"><em>k</em>-means clustering</a>, the goal is to partition <em>N</em> cells into <em>k</em> different clusters. In an iterative manner, cluster centers are assigned and each cell is assigned to its nearest cluster:</p>
<div class="figure" style="text-align: center"><span id="fig:clust-k-means"></span>
<img src="figures/k-means.png" alt="Schematic representation of the k-means clustering" width="100%" />
<p class="caption">
Figure 8.3: Schematic representation of the k-means clustering
</p>
</div>
<p>Most methods for scRNA-seq analysis includes a <em>k</em>-means step at some point.</p>
</div>
<div id="graph-based-methods" class="section level4">
<h4><span class="header-section-number">8.1.3.3</span> Graph-based methods</h4>
<p>Over the last two decades there has been a lot of interest in analyzing networks in various domains. One goal is to identify groups or modules of nodes in a network.</p>
<div class="figure" style="text-align: center"><span id="fig:clust-graph"></span>
<img src="figures/graph_network.jpg" alt="Schematic representation of the graph network" width="100%" />
<p class="caption">
Figure 8.4: Schematic representation of the graph network
</p>
</div>
<p>Some of these methods can be applied to scRNA-seq data by building a graph where each node represents a cell. Note that constructing the graph and assigning weights to the edges is not trivial. One advantage of graph-based methods is that some of them are very efficient and can be applied to networks containing millions of nodes.</p>
</div>
</div>
<div id="challenges-in-clustering" class="section level3">
<h3><span class="header-section-number">8.1.4</span> Challenges in clustering</h3>
<ul>
<li>What is the number of clusters <em>k</em>?</li>
<li>What is a cell type?</li>
<li><strong>Scalability</strong>: in the last few years the number of cells in scRNA-seq experiments has grown by several orders of magnitude from ~<span class="math inline">\(10^2\)</span> to ~<span class="math inline">\(10^6\)</span></li>
<li>Tools are not user-friendly</li>
</ul>
</div>
<div id="tools-for-scrna-seq-data" class="section level3">
<h3><span class="header-section-number">8.1.5</span> Tools for scRNA-seq data</h3>
<div id="sincera" class="section level4">
<h4><span class="header-section-number">8.1.5.1</span> <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a></h4>
<ul>
<li>SINCERA <span class="citation">(Guo et al. <a href="#ref-Guo2015-ok">2015</a>)</span> is based on hierarchical clustering</li>
<li>Data is converted to <em>z</em>-scores before clustering</li>
<li>Identify <em>k</em> by finding the first singleton cluster in the hierarchy</li>
</ul>
</div>
<div id="pcareduce" class="section level4">
<h4><span class="header-section-number">8.1.5.2</span> <a href="https://github.com/JustinaZ/pcaReduce">pcaReduce</a></h4>
<p>pcaReduce <span class="citation">(žurauskienė and Yau <a href="#ref-Zurauskiene2016-kg">2016</a>)</span> combines PCA, <em>k</em>-means and “iterative” hierarchical clustering. Starting from a large number of clusters pcaReduce iteratively merges similar clusters; after each merging event it removes the principle component explaning the least variance in the data.</p>
</div>
<div id="sc3" class="section level4">
<h4><span class="header-section-number">8.1.5.3</span> <a href="http://bioconductor.org/packages/SC3/">SC3</a></h4>
<div class="figure" style="text-align: center"><span id="fig:clust-sc3"></span>
<img src="figures/sc3.png" alt="SC3 pipeline" width="100%" />
<p class="caption">
Figure 8.5: SC3 pipeline
</p>
</div>
<ul>
<li>SC3 <span class="citation">(Kiselev et al. <a href="#ref-Kiselev2016-bq">2017</a>)</span> is based on PCA and spectral dimensionality reductions</li>
<li>Utilises <em>k</em>-means</li>
<li>Additionally performs the consensus clustering</li>
</ul>
</div>
<div id="tsne-k-means" class="section level4">
<h4><span class="header-section-number">8.1.5.4</span> tSNE + k-means</h4>
<ul>
<li>Based on <strong>tSNE</strong> maps</li>
<li>Utilises <em>k</em>-means</li>
</ul>
</div>
<div id="snn-cliq" class="section level4">
<h4><span class="header-section-number">8.1.5.5</span> <a href="http://bioinfo.uncc.edu/SNNCliq/">SNN-Cliq</a></h4>
<p><code>SNN-Cliq</code> <span class="citation">(C. Xu and Su <a href="#ref-Xu2015-vf">2015</a>)</span> is a graph-based method. First the method identifies the k-nearest-neighbours of each cell according to the <em>distance</em> measure. This is used to calculate the number of Shared Nearest Neighbours (SNN) between each pair of cells. A graph is built by placing an edge between two cells If they have at least one SNN. Clusters are defined as groups of cells with many edges between them using a “clique” method. SNN-Cliq requires several parameters to be defined manually.</p>
</div>
<div id="seurat-clustering" class="section level4">
<h4><span class="header-section-number">8.1.5.6</span> Seurat clustering</h4>
<p><a href="https://github.com/satijalab/seurat"><code>Seurat</code></a> clustering is based on a <em>community detection</em> approach similar to <code>SNN-Cliq</code> and to one previously proposed for analyzing CyTOF data <span class="citation">(Levine et al. <a href="#ref-Levine2015-fk">2015</a>)</span>. Since <code>Seurat</code> has become more like an all-in-one tool for scRNA-seq data analysis we dedicate a separate chapter to discuss it in more details (chapter <a href="seurat-chapter.html#seurat-chapter">9</a>).</p>
</div>
</div>
<div id="comparing-clustering" class="section level3">
<h3><span class="header-section-number">8.1.6</span> Comparing clustering</h3>
<p>To compare two sets of clustering labels we can use <a href="https://en.wikipedia.org/wiki/Rand_index">adjusted Rand index</a>. The index is a measure of the similarity between two data clusterings. Values of the adjusted Rand index lie in <span class="math inline">\([0;1]\)</span> interval, where <span class="math inline">\(1\)</span> means that two clusterings are identical and <span class="math inline">\(0\)</span> means the level of similarity expected by chance.</p>

</div>
</div>
<div id="clust-methods" class="section level2">
<h2><span class="header-section-number">8.2</span> Clustering example</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(pcaMethods)
<span class="kw">library</span>(pcaReduce)
<span class="kw">library</span>(SC3)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(pheatmap)
<span class="kw">library</span>(mclust)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>To illustrate clustering of scRNA-seq data, we consider the <code>Deng</code> dataset of cells from developing mouse embryo <span class="citation">(Deng et al. <a href="#ref-Deng2014-mx">2014</a>)</span>. We have preprocessed the dataset and created a <code>SingleCellExperiment</code> object in advance. We have also annotated the cells with the cell types identified in the original publication (it is the <code>cell_type2</code> column in the <code>colData</code> slot).</p>
<div id="deng-dataset" class="section level3">
<h3><span class="header-section-number">8.2.1</span> Deng dataset</h3>
<p>Let’s load the data and look at it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
deng</code></pre></div>
<pre><code>## class: SingleCellExperiment 
## dim: 22431 268 
## metadata(0):
## assays(2): counts logcounts
## rownames(22431): Hvcn1 Gbp7 ... Sox5 Alg11
## rowData names(10): feature_symbol is_feature_control ...
##   total_counts log10_total_counts
## colnames(268): 16cell 16cell.1 ... zy.2 zy.3
## colData names(30): cell_type2 cell_type1 ... pct_counts_ERCC
##   is_cell_control
## reducedDimNames(0):
## spikeNames(1): ERCC</code></pre>
<p>Let’s look at the cell type annotation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2)</code></pre></div>
<pre><code>## 
##     16cell      4cell      8cell early2cell earlyblast  late2cell 
##         50         14         37          8         43         10 
##  lateblast   mid2cell   midblast         zy 
##         30         12         60          4</code></pre>
<p>A simple PCA analysis already separates some strong cell types and provides some insights in the data structure:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /> As you can see, the early cell types separate quite well, but the three blastocyst timepoints are more difficult to distinguish.</p>
</div>
<div id="sc3-1" class="section level3">
<h3><span class="header-section-number">8.2.2</span> SC3</h3>
<p>Let’s run <code>SC3</code> clustering on the Deng data. The advantage of the <code>SC3</code> is that it can directly ingest a <code>SingleCellExperiment</code> object.</p>
<p>Now let’s image we do not know the number of clusters <em>k</em> (cell types). <code>SC3</code> can estimate a number of clusters for you:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(deng)</code></pre></div>
<pre><code>## Estimating k...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">metadata</span>(deng)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>Interestingly, the number of cell types predicted by <code>SC3</code> is smaller than in the original data annotation. However, early, mid and late stages of different cell types together, we will have exactly 6 cell types. We store the merged cell types in <code>cell_type1</code> column of the <code>colData</code> slot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type1&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Now we are ready to run <code>SC3</code> (we also ask it to calculate biological properties of the clusters):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">sc3</span>(deng, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">biology =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Setting SC3 parameters...</code></pre>
<pre><code>## Calculating distances between the cells...</code></pre>
<pre><code>## Performing transformations and calculating eigenvectors...</code></pre>
<pre><code>## Performing k-means clustering...</code></pre>
<pre><code>## Calculating consensus matrix...</code></pre>
<pre><code>## Calculating biology...</code></pre>
<p><code>SC3</code> result consists of several different outputs (please look in <span class="citation">(Kiselev et al. <a href="#ref-Kiselev2016-bq">2017</a>)</span> and <a href="http://bioconductor.org/packages/release/bioc/vignettes/SC3/inst/doc/my-vignette.html">SC3 vignette</a> for more details). Here we show some of them:</p>
<p>Consensus matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_consensus</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-9-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Silhouette plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_silhouette</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Heatmap of the expression matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_expression</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Identified marker genes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_markers</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>PCA plot with highlighted <code>SC3</code> clusters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Compare the results of <code>SC3</code> clustering with the original publication cell type labels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">adjustedRandIndex</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2, <span class="kw">colData</span>(deng)<span class="op">$</span>sc3_10_clusters)</code></pre></div>
<pre><code>## [1] 0.7705208</code></pre>
<p><strong>Note</strong> <code>SC3</code> can also be run in an interactive <code>Shiny</code> session:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_interactive</span>(deng)</code></pre></div>
<p>This command will open <code>SC3</code> in a web browser.</p>
<p><strong>Note</strong> Due to direct calculation of distances <code>SC3</code> becomes very slow when the number of cells is <span class="math inline">\(&gt;5000\)</span>. For large datasets containing up to <span class="math inline">\(10^5\)</span> cells we recomment using <code>Seurat</code> (see chapter <a href="seurat-chapter.html#seurat-chapter">9</a>).</p>
<ul>
<li><p><strong>Exercise 1</strong>: Run <code>SC3</code> for <span class="math inline">\(k\)</span> from 8 to 12 and explore different clustering solutions in your web browser.</p></li>
<li><p><strong>Exercise 2</strong>: Which clusters are the most stable when <span class="math inline">\(k\)</span> is changed from 8 to 12? (Look at the “Stability” tab)</p></li>
<li><p><strong>Exercise 3</strong>: Check out differentially expressed genes and marker genes for the obtained clusterings. Please use <span class="math inline">\(k=10\)</span>.</p></li>
<li><p><strong>Exercise 4</strong>: Change the marker genes threshold (the default is 0.85). Does <strong>SC3</strong> find more marker genes?</p></li>
</ul>
</div>
<div id="pcareduce-1" class="section level3">
<h3><span class="header-section-number">8.2.3</span> pcaReduce</h3>
<p><code>pcaReduce</code> operates directly on the expression matrix. It is recommended to use a gene filter and log transformation before running <code>pcaReduce</code>. We will use the default <code>SC3</code> gene filter (note that the <code>exprs</code> slot of a <code>scater</code> object is log-transformed by default).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># use the same gene filter as in SC3</span>
input &lt;-<span class="st"> </span><span class="kw">logcounts</span>(deng[<span class="kw">rowData</span>(deng)<span class="op">$</span>sc3_gene_filter, ])</code></pre></div>
<p>There are several parameters used by <code>pcaReduce</code>: * <code>nbt</code> defines a number of <code>pcaReduce</code> runs (it is stochastic and may have different solutions after different runs) * <code>q</code> defines number of dimensions to start clustering with. The output will contain partitions for all <span class="math inline">\(k\)</span> from 2 to q+1. * <code>method</code> defines a method used for clustering. <code>S</code> - to perform sampling based merging, <code>M</code> - to perform merging based on largest probability.</p>
<p>We will run <code>pcaReduce</code> 1 time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># run pcaReduce 1 time creating hierarchies from 1 to 30 clusters</span>
pca.red &lt;-<span class="st"> </span><span class="kw">PCAreduce</span>(<span class="kw">t</span>(input), <span class="dt">nbt =</span> <span class="dv">1</span>, <span class="dt">q =</span> <span class="dv">30</span>, <span class="dt">method =</span> <span class="st">&#39;S&#39;</span>)[[<span class="dv">1</span>]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(deng)<span class="op">$</span>pcaReduce &lt;-<span class="st"> </span><span class="kw">as.character</span>(pca.red[,<span class="dv">32</span> <span class="op">-</span><span class="st"> </span><span class="dv">10</span>])
<span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;pcaReduce&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 5</strong>: Run pcaReduce for <span class="math inline">\(k=2\)</span> and plot a similar PCA plot. Does it look good?</p>
<p><strong>Hint</strong>: When running pcaReduce for different <span class="math inline">\(k\)</span>s you do not need to rerun PCAreduce function, just use already calculated <code>pca.red</code> object.</p>
<strong>Our solution</strong>:
<div class="figure" style="text-align: center"><span id="fig:clust-pca-reduce2"></span>
<img src="25-clustering_files/figure-html/clust-pca-reduce2-1.png" alt="Clustering solutions of pcaReduce method for $k=2$." width="672" />
<p class="caption">
Figure 8.6: Clustering solutions of pcaReduce method for <span class="math inline">\(k=2\)</span>.
</p>
</div>
<p><strong>Exercise 6</strong>: Compare the results between <code>pcaReduce</code> and the original publication cell types for <span class="math inline">\(k=10\)</span>.</p>
<p><strong>Our solution</strong>:</p>
<pre><code>## [1] 0.4216031</code></pre>
</div>
<div id="tsne-kmeans" class="section level3">
<h3><span class="header-section-number">8.2.4</span> tSNE + kmeans</h3>
<p><a href="https://lvdmaaten.github.io/tsne/">tSNE</a> plots that we saw before (<a href="cleaning-the-expression-matrix.html#visual-tsne">7.3.3</a>) when used the <strong>scater</strong> package are made by using the <a href="https://cran.r-project.org/web/packages/Rtsne/index.html">Rtsne</a> and <a href="https://cran.r-project.org/web/packages/ggplot2/index.html">ggplot2</a> packages. Here we will do the same:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">plotTSNE</span>(deng, <span class="dt">rand_seed =</span> <span class="dv">1</span>, <span class="dt">return_SCE =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-tsne"></span>
<img src="25-clustering_files/figure-html/clust-tsne-1.png" alt="tSNE map of the patient data" width="672" />
<p class="caption">
Figure 8.7: tSNE map of the patient data
</p>
</div>
<p>Note that all points on the plot above are black. This is different from what we saw before, when the cells were coloured based on the annotation. Here we do not have any annotation and all cells come from the same batch, therefore all dots are black.</p>
<p>Now we are going to apply <em>k</em>-means clustering algorithm to the cloud of points on the tSNE map. How many groups do you see in the cloud?</p>
<p>We will start with <span class="math inline">\(k=8\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(deng)<span class="op">$</span>tSNE_kmeans &lt;-<span class="st"> </span><span class="kw">as.character</span>(<span class="kw">kmeans</span>(deng<span class="op">@</span>reducedDims<span class="op">$</span>TSNE, <span class="dt">centers =</span> <span class="dv">8</span>)<span class="op">$</span>clust)
<span class="kw">plotTSNE</span>(deng, <span class="dt">rand_seed =</span> <span class="dv">1</span>, <span class="dt">colour_by =</span> <span class="st">&quot;tSNE_kmeans&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-tsne-kmeans2"></span>
<img src="25-clustering_files/figure-html/clust-tsne-kmeans2-1.png" alt="tSNE map of the patient data with 8 colored clusters, identified by the k-means clustering algorithm" width="672" />
<p class="caption">
Figure 8.8: tSNE map of the patient data with 8 colored clusters, identified by the k-means clustering algorithm
</p>
</div>
<p><strong>Exercise 7</strong>: Make the same plot for <span class="math inline">\(k=10\)</span>.</p>
<p><strong>Exercise 8</strong>: Compare the results between <code>tSNE+kmeans</code> and the original publication cell types. Can the results be improved by changing the <code>perplexity</code> parameter?</p>
<p><strong>Our solution</strong>:</p>
<pre><code>## [1] 0.3701639</code></pre>
<p>As you may have noticed, both <code>pcaReduce</code> and <code>tSNE+kmeans</code> are stochastic and give different results every time they are run. To get a better overview of the solutions, we need to run the methods multiple times. <code>SC3</code> is also stochastic, but thanks to the consensus step, it is more robust and less likely to produce different outcomes.</p>
</div>
<div id="snn-cliq-1" class="section level3">
<h3><span class="header-section-number">8.2.5</span> SNN-Cliq</h3>
<p>Here we run SNN-cliq with te default parameters provided in the author’s example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">distan &lt;-<span class="st"> &quot;euclidean&quot;</span>
par.k &lt;-<span class="st"> </span><span class="dv">3</span>
par.r &lt;-<span class="st"> </span><span class="fl">0.7</span>
par.m &lt;-<span class="st"> </span><span class="fl">0.5</span>
<span class="co"># construct a graph</span>
scRNA.seq.funcs<span class="op">::</span><span class="kw">SNN</span>(
    <span class="dt">data =</span> <span class="kw">t</span>(input),
    <span class="dt">outfile =</span> <span class="st">&quot;snn-cliq.txt&quot;</span>,
    <span class="dt">k =</span> par.k,
    <span class="dt">distance =</span> distan
)
<span class="co"># find clusters in the graph</span>
snn.res &lt;-<span class="st"> </span>
<span class="st">    </span><span class="kw">system</span>(
        <span class="kw">paste0</span>(
            <span class="st">&quot;python utils/Cliq.py &quot;</span>, 
            <span class="st">&quot;-i snn-cliq.txt &quot;</span>,
            <span class="st">&quot;-o res-snn-cliq.txt &quot;</span>,
            <span class="st">&quot;-r &quot;</span>, par.r,
            <span class="st">&quot; -m &quot;</span>, par.m
        ),
        <span class="dt">intern =</span> <span class="ot">TRUE</span>
    )
<span class="kw">cat</span>(<span class="kw">paste</span>(snn.res, <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))</code></pre></div>
<pre><code>## input file snn-cliq.txt
## find 66 quasi-cliques
## merged into 29 clusters
## unique assign done</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">snn.res &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;res-snn-cliq.txt&quot;</span>)
<span class="co"># remove files that were created during the analysis</span>
<span class="kw">system</span>(<span class="st">&quot;rm snn-cliq.txt res-snn-cliq.txt&quot;</span>)

<span class="kw">colData</span>(deng)<span class="op">$</span>SNNCliq &lt;-<span class="st"> </span><span class="kw">as.character</span>(snn.res[,<span class="dv">1</span>])
<span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;SNNCliq&quot;</span>)</code></pre></div>
<p><img src="25-clustering_files/figure-html/unnamed-chunk-21-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 9</strong>: Compare the results between <code>SNN-Cliq</code> and the original publication cell types.</p>
<p><strong>Our solution</strong>:</p>
<pre><code>## [1] 0.2629731</code></pre>
</div>
<div id="sincera-1" class="section level3">
<h3><span class="header-section-number">8.2.6</span> SINCERA</h3>
<p>As mentioned in the previous chapter <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a> is based on hierarchical clustering. One important thing to keep in mind is that it performs a gene-level z-score transformation before doing clustering:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># perform gene-by-gene per-sample z-score transformation</span>
dat &lt;-<span class="st"> </span><span class="kw">apply</span>(input, <span class="dv">1</span>, <span class="cf">function</span>(y) scRNA.seq.funcs<span class="op">::</span><span class="kw">z.transform.helper</span>(y))
<span class="co"># hierarchical clustering</span>
dd &lt;-<span class="st"> </span><span class="kw">as.dist</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">cor</span>(<span class="kw">t</span>(dat), <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>))<span class="op">/</span><span class="dv">2</span>)
hc &lt;-<span class="st"> </span><span class="kw">hclust</span>(dd, <span class="dt">method =</span> <span class="st">&quot;average&quot;</span>)</code></pre></div>
<p>If the number of cluster is not known <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a> can identify <strong>k</strong> as the minimum height of the hierarchical tree that generates no more than a specified number of singleton clusters (clusters containing only 1 cell)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">num.singleton &lt;-<span class="st"> </span><span class="dv">0</span>
kk &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">dim</span>(dat)[<span class="dv">2</span>]) {
    clusters &lt;-<span class="st"> </span><span class="kw">cutree</span>(hc, <span class="dt">k =</span> i)
    clustersizes &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">table</span>(clusters))
    singleton.clusters &lt;-<span class="st"> </span><span class="kw">which</span>(clustersizes<span class="op">$</span>Freq <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>)
    <span class="cf">if</span> (<span class="kw">length</span>(singleton.clusters) <span class="op">&lt;=</span><span class="st"> </span>num.singleton) {
        kk &lt;-<span class="st"> </span>i
    } <span class="cf">else</span> {
        <span class="cf">break</span>;
    }
}
<span class="kw">cat</span>(kk)</code></pre></div>
<pre><code>## 6</code></pre>
<p>Let’s now visualize the SINCERA results as a heatmap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pheatmap</span>(
    <span class="kw">t</span>(dat),
    <span class="dt">cluster_cols =</span> hc,
    <span class="dt">cutree_cols =</span> kk,
    <span class="dt">kmeans_k =</span> <span class="dv">100</span>,
    <span class="dt">show_rownames =</span> <span class="ot">FALSE</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-sincera"></span>
<img src="25-clustering_files/figure-html/clust-sincera-1.png" alt="Clustering solutions of SINCERA method using found $k$" width="672" />
<p class="caption">
Figure 8.9: Clustering solutions of SINCERA method using found <span class="math inline">\(k\)</span>
</p>
</div>
<p><strong>Exercise 10</strong>: Compare the results between <code>SINCERA</code> and the original publication cell types.</p>
<p><strong>Our solution</strong>:</p>
<pre><code>## [1] 0.3823537</code></pre>
<p><strong>Exercise 11</strong>: Is using the singleton cluster criteria for finding <strong>k</strong> a good idea?</p>
</div>
<div id="sessioninfo-5" class="section level3">
<h3><span class="header-section-number">8.2.7</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] pheatmap_1.0.8             scater_1.6.3              
##  [3] SingleCellExperiment_1.0.0 SummarizedExperiment_1.8.1
##  [5] DelayedArray_0.4.1         matrixStats_0.53.1        
##  [7] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
##  [9] IRanges_2.12.0             S4Vectors_0.16.0          
## [11] ggplot2_2.2.1              SC3_1.7.7                 
## [13] pcaReduce_1.0              mclust_5.4                
## [15] mnormt_1.5-5               pcaMethods_1.70.0         
## [17] Biobase_2.38.0             BiocGenerics_0.24.0       
## [19] knitr_1.20                
## 
## loaded via a namespace (and not attached):
##   [1] Rtsne_0.13             ggbeeswarm_0.6.0       colorspace_1.3-2      
##   [4] rjson_0.2.15           class_7.3-14           rprojroot_1.3-2       
##   [7] XVector_0.18.0         bit64_0.9-7            AnnotationDbi_1.40.0  
##  [10] mvtnorm_1.0-7          scRNA.seq.funcs_0.1.0  codetools_0.2-15      
##  [13] tximport_1.6.0         doParallel_1.0.11      robustbase_0.92-8     
##  [16] cluster_2.0.6          shinydashboard_0.6.1   shiny_1.0.5           
##  [19] rrcov_1.4-3            compiler_3.4.3         httr_1.3.1            
##  [22] backports_1.1.2        assertthat_0.2.0       Matrix_1.2-7.1        
##  [25] lazyeval_0.2.1         limma_3.34.9           htmltools_0.3.6       
##  [28] prettyunits_1.0.2      tools_3.4.3            bindrcpp_0.2          
##  [31] gtable_0.2.0           glue_1.2.0             GenomeInfoDbData_1.0.0
##  [34] reshape2_1.4.3         dplyr_0.7.4            doRNG_1.6.6           
##  [37] Rcpp_0.12.15           gdata_2.18.0           iterators_1.0.9       
##  [40] xfun_0.1               stringr_1.3.0          mime_0.5              
##  [43] hypergeo_1.2-13        rngtools_1.2.4         gtools_3.5.0          
##  [46] WriteXLS_4.0.0         statmod_1.4.30         XML_3.98-1.10         
##  [49] edgeR_3.20.9           DEoptimR_1.0-8         MASS_7.3-45           
##  [52] zlibbioc_1.24.0        scales_0.5.0           rhdf5_2.22.0          
##  [55] RColorBrewer_1.1-2     yaml_2.1.17            memoise_1.1.0         
##  [58] gridExtra_2.3          pkgmaker_0.22          biomaRt_2.34.2        
##  [61] stringi_1.1.6          RSQLite_2.0            highr_0.6             
##  [64] pcaPP_1.9-73           foreach_1.4.4          orthopolynom_1.0-5    
##  [67] e1071_1.6-8            contfrac_1.1-11        caTools_1.17.1        
##  [70] moments_0.14           rlang_0.2.0            pkgconfig_2.0.1       
##  [73] bitops_1.0-6           evaluate_0.10.1        lattice_0.20-34       
##  [76] ROCR_1.0-7             bindr_0.1              labeling_0.3          
##  [79] cowplot_0.9.2          bit_1.1-12             deSolve_1.20          
##  [82] plyr_1.8.4             magrittr_1.5           bookdown_0.7          
##  [85] R6_2.2.2               gplots_3.0.1           DBI_0.7               
##  [88] pillar_1.2.1           RCurl_1.95-4.10        tibble_1.4.2          
##  [91] KernSmooth_2.23-15     rmarkdown_1.8          viridis_0.5.0         
##  [94] progress_1.1.2         locfit_1.5-9.1         grid_3.4.3            
##  [97] data.table_1.10.4-3    blob_1.1.0             digest_0.6.15         
## [100] xtable_1.8-2           httpuv_1.3.6.1         elliptic_1.3-7        
## [103] munsell_0.4.3          registry_0.5           beeswarm_0.2.3        
## [106] viridisLite_0.3.0      vipor_0.4.5</code></pre>

</div>
</div>
<div id="feature-selection" class="section level2">
<h2><span class="header-section-number">8.3</span> Feature Selection</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(matrixStats)
<span class="kw">library</span>(M3Drop)
<span class="kw">library</span>(RColorBrewer)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<p>Single-cell RNASeq is capable of measuring the expression of many thousands of genes in every cell. However, in most situations only a portion of those will show a response to the biological condition of interest, e.g. differences in cell-type, drivers of differentiation, respond to an environmental stimulus. Most genes detected in a scRNASeq experiment will only be detected at different levels due to technical noise. One consequence of this is that technical noise and batch effects can obscure the biological signal of interest.</p>
<p>Thus, it is often advantageous to perform feature selection to remove those genes which only exhibit technical noise from downstream analysis. Not only does this generally increase the signal:noise ratio in the data; it also reduces the computational complexity of analyses, by reducing the total amount of data to be processed.</p>
<p>For scRNASeq data, we will be focusing on unsupervised methods of feature selection which don’t require any a priori information, such as cell-type labels or biological group, since they are not available, or may be unreliable, for many experiments. In contrast, differential expression (chapter <a href="biological-analysis.html#dechapter">8.6</a>) can be considered a form of supervised feature selection since it uses the known biological label of each sample to identify features (i.e. genes) which are expressed at different levels across groups.</p>
<p>For this section we will continue working with the Deng data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
cellLabels &lt;-<span class="st"> </span><span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2</code></pre></div>
<p>This data can be QCed and normalized for library size using M3Drop, which removes cells with few detected genes, removes undetected genes, and converts raw counts to CPM.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_list &lt;-<span class="st"> </span><span class="kw">M3DropCleanData</span>(
    <span class="kw">counts</span>(deng),
    <span class="dt">labels =</span> cellLabels,
    <span class="dt">min_detected_genes =</span> <span class="dv">100</span>,
    <span class="dt">is.counts =</span> <span class="ot">TRUE</span>
)
expr_matrix &lt;-<span class="st"> </span>deng_list<span class="op">$</span>data <span class="co"># Normalized &amp; filtered expression matrix</span>
celltype_labs &lt;-<span class="st"> </span><span class="kw">factor</span>(deng_list<span class="op">$</span>labels) <span class="co"># filtered cell-type labels</span>
cell_colors &lt;-<span class="st"> </span><span class="kw">brewer.pal</span>(<span class="kw">max</span>(<span class="dv">3</span>,<span class="kw">length</span>(<span class="kw">unique</span>(celltype_labs))), <span class="st">&quot;Set3&quot;</span>)</code></pre></div>
<p><strong>Exercise 1</strong>: How many cells &amp; genes have been removed by this filtering?</p>
<div id="identifying-genes-vs-a-null-model" class="section level3">
<h3><span class="header-section-number">8.3.1</span> Identifying Genes vs a Null Model</h3>
<p>There are two main approaches to unsupervised feature selection. The first is to identify genes which behave differently from a null model describing just the technical noise expected in the dataset.</p>
<p>If the dataset contains spike-in RNAs they can be used to directly model technical noise. However, measurements of spike-ins may not experience the same technical noise as endogenous transcripts <a href="https://www.nature.com/nmeth/journal/v14/n4/full/nmeth.4220.html">(Svensson et al., 2017)</a>. In addition, scRNASeq experiments often contain only a small number of spike-ins which reduces our confidence in fitted model parameters.</p>
<div id="highly-variable-genes" class="section level4">
<h4><span class="header-section-number">8.3.1.1</span> Highly Variable Genes</h4>
<p>The first method proposed to identify features in scRNASeq datasets was to identify highly variable genes (HVG). HVG assumes that if genes have large differences in expression across cells some of those differences are due to biological difference between the cells rather than technical noise. However, because of the nature of count data, there is a positive relationship between the mean expression of a gene and the variance in the read counts across cells. This relationship must be corrected for to properly identify HVGs.</p>
<p><strong>Exercise 2</strong> Using the functions rowMeans and rowVars to plot the relationship between mean expression and variance for all genes in this dataset. (Hint: use log=“xy” to plot on a log-scale).</p>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-6-1.png" width="816" style="display: block; margin: auto;" /> A popular method to correct for the relationship between variance and mean expression was proposed by <a href="http://www.nature.com/nmeth/journal/v10/n11/full/nmeth.2645.html">Brennecke et al.</a>. To use the Brennecke method, we first normalize for library size then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A quadratic curve is fit to the relationship between these two variables for the ERCC spike-in, and then a chi-square test is used to find genes significantly above the curve. This method is included in the M3Drop package as the Brennecke_getVariableGenes(counts, spikes) function. However, this dataset does not contain spike-ins so we will use the entire dataset to estimate the technical noise.</p>
<p>In the figure below the red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Brennecke_HVG &lt;-<span class="st"> </span><span class="kw">BrenneckeGetVariableGenes</span>(
    expr_matrix,
    <span class="dt">fdr =</span> <span class="fl">0.01</span>,
    <span class="dt">minBiolDisp =</span> <span class="fl">0.5</span>
)</code></pre></div>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">HVG_genes &lt;-<span class="st"> </span>Brennecke_HVG<span class="op">$</span>Gene</code></pre></div>
</div>
<div id="high-dropout-genes" class="section level4">
<h4><span class="header-section-number">8.3.1.2</span> High Dropout Genes</h4>
<p>An alternative to finding HVGs is to identify genes with unexpectedly high numbers of zeros. The frequency of zeros, know as the “dropout rate”, is very closely related to expression level in scRNASeq data. Zeros are the dominant feature of single-cell RNASeq data, typically accounting for over half of the entries in the final expression matrix. These zeros predominantly result from the failure of mRNAs failing to be reversed transcribed <a href="http://www.biorxiv.org/content/early/2017/05/25/065094">(Andrews and Hemberg, 2016)</a>. Reverse transcription is an enzyme reaction thus can be modelled using the Michaelis-Menten equation:</p>
<p><span class="math display">\[P_{dropout} = 1 - S/(K + S)\]</span></p>
<p>where <span class="math inline">\(S\)</span> is the mRNA concentration in the cell (we will estimate this as average expression) and <span class="math inline">\(K\)</span> is the Michaelis-Menten constant.</p>
<p>Because the Michaelis-Menten equation is a convex non-linear function, genes which are differentially expression across two or more populations of cells in our dataset will be shifted up/right of the Michaelis-Menten model (see Figure below).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">K &lt;-<span class="st"> </span><span class="dv">49</span>
S_sim &lt;-<span class="st"> </span><span class="dv">10</span><span class="op">^</span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="op">-</span><span class="dv">3</span>, <span class="dt">to =</span> <span class="dv">4</span>, <span class="dt">by =</span> <span class="fl">0.05</span>) <span class="co"># range of expression values</span>
MM &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>S_sim <span class="op">/</span><span class="st"> </span>(K <span class="op">+</span><span class="st"> </span>S_sim)
<span class="kw">plot</span>(
    S_sim, 
    MM, 
    <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, 
    <span class="dt">lwd =</span> <span class="dv">3</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Expression&quot;</span>, 
    <span class="dt">ylab =</span> <span class="st">&quot;Dropout Rate&quot;</span>, 
    <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1000</span>)
)
S1 &lt;-<span class="st"> </span><span class="dv">10</span>
P1 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>S1 <span class="op">/</span><span class="st"> </span>(K <span class="op">+</span><span class="st"> </span>S1) <span class="co"># Expression &amp; dropouts for cells in condition 1</span>
S2 &lt;-<span class="st"> </span><span class="dv">750</span>
P2 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>S2 <span class="op">/</span><span class="st"> </span>(K <span class="op">+</span><span class="st"> </span>S2) <span class="co"># Expression &amp; dropouts for cells in condition 2</span>
<span class="kw">points</span>(
    <span class="kw">c</span>(S1, S2),
    <span class="kw">c</span>(P1, P2), 
    <span class="dt">pch =</span> <span class="dv">16</span>, 
    <span class="dt">col =</span> <span class="st">&quot;grey85&quot;</span>, 
    <span class="dt">cex =</span> <span class="dv">3</span>
)
mix &lt;-<span class="st"> </span><span class="fl">0.5</span> <span class="co"># proportion of cells in condition 1</span>
<span class="kw">points</span>(
    S1 <span class="op">*</span><span class="st"> </span>mix <span class="op">+</span><span class="st"> </span>S2 <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mix), 
    P1 <span class="op">*</span><span class="st"> </span>mix <span class="op">+</span><span class="st"> </span>P2 <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>mix), 
    <span class="dt">pch =</span> <span class="dv">16</span>, 
    <span class="dt">col =</span> <span class="st">&quot;grey35&quot;</span>, 
    <span class="dt">cex =</span> <span class="dv">3</span>
)</code></pre></div>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-8-1.png" width="816" style="display: block; margin: auto;" /> <strong>Note</strong>: add <code>log=&quot;x&quot;</code> to the <code>plot</code> call above to see how this looks on the log scale, which is used in M3Drop figures.</p>
<p><strong>Exercise 3</strong>: Produce the same plot as above with different expression levels (S1 &amp; S2) and/or mixtures (mix).</p>
<p>We use M3Drop to identify significant outliers to the right of the MM curve. We also apply 1% FDR multiple testing correction:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M3Drop_genes &lt;-<span class="st"> </span><span class="kw">M3DropFeatureSelection</span>(
    expr_matrix,
    <span class="dt">mt_method =</span> <span class="st">&quot;fdr&quot;</span>,
    <span class="dt">mt_threshold =</span> <span class="fl">0.01</span>
)</code></pre></div>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M3Drop_genes &lt;-<span class="st"> </span>M3Drop_genes<span class="op">$</span>Gene</code></pre></div>
<p>An alternative method is contained in the M3Drop package that is tailored specifically for UMI-tagged data which generally contains many zeros resulting from low sequencing coverage in addition to those resulting from insufficient reverse-transcription. This model is the Depth-Adjusted Negative Binomial (DANB). This method describes each expression observation as a negative binomial model with a mean related to both the mean expression of the respective gene and the sequencing depth of the respective cell, and a variance related to the mean-expression of the gene.</p>
<p>Unlike the Michaelis-Menten and HVG methods there isn’t a reliable statistical test for features selected by this model, so we will consider the top 1500 genes instead.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_int &lt;-<span class="st"> </span><span class="kw">NBumiConvertToInteger</span>(<span class="kw">counts</span>(deng))
DANB_fit &lt;-<span class="st"> </span><span class="kw">NBumiFitModel</span>(deng_int) <span class="co"># DANB is fit to the raw count matrix</span>
<span class="co"># Perform DANB feature selection</span>
DropFS &lt;-<span class="st"> </span><span class="kw">NBumiFeatureSelectionCombinedDrop</span>(DANB_fit)
DANB_genes &lt;-<span class="st"> </span><span class="kw">names</span>(DropFS[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
</div>
</div>
<div id="correlated-expression" class="section level3">
<h3><span class="header-section-number">8.3.2</span> Correlated Expression</h3>
<p>A completely different approach to feature selection is to use gene-gene correlations. This method is based on the idea that multiple genes will be differentially expressed between different cell-types or cell-states. Genes which are expressed in the same cell-population will be positively correlated with each other where as genes expressed in different cell-populations will be negatively correated with each other. Thus important genes can be identified by the magnitude of their correlation with other genes.</p>
<p>The limitation of this method is that it assumes technical noise is random and independent for each cell, thus shouldn’t produce gene-gene correlations, but this assumption is violated by batch effects which are generally systematic between different experimental batches and will produce gene-gene correlations. As a result it is more appropriate to take the top few thousand genes as ranked by gene-gene correlation than consider the significance of the correlations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_mat &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="kw">t</span>(expr_matrix), <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>) <span class="co"># Gene-gene correlations</span>
<span class="kw">diag</span>(cor_mat) &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dt">times =</span> <span class="kw">nrow</span>(expr_matrix))
score &lt;-<span class="st"> </span><span class="kw">apply</span>(cor_mat, <span class="dv">1</span>, <span class="cf">function</span>(x) {<span class="kw">max</span>(<span class="kw">abs</span>(x))}) <span class="co">#Correlation of highest magnitude</span>
<span class="kw">names</span>(score) &lt;-<span class="st"> </span><span class="kw">rownames</span>(expr_matrix);
score &lt;-<span class="st"> </span>score[<span class="kw">order</span>(<span class="op">-</span>score)]
Cor_genes &lt;-<span class="st"> </span><span class="kw">names</span>(score[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
<p>Lastly, another common method for feature selection in scRNASeq data is to use PCA loadings. Genes with high PCA loadings are likely to be highly variable and correlated with many other variable genes, thus may be relevant to the underlying biology. However, as with gene-gene correlations PCA loadings tend to be susceptible to detecting systematic variation due to batch effects; thus it is recommended to plot the PCA results to determine those components corresponding to the biological variation rather than batch effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># PCA is typically performed on log-transformed expression data</span>
pca &lt;-<span class="st"> </span><span class="kw">prcomp</span>(<span class="kw">log</span>(expr_matrix <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span>))

<span class="co"># plot projection</span>
<span class="kw">plot</span>(
    pca<span class="op">$</span>rotation[,<span class="dv">1</span>], 
    pca<span class="op">$</span>rotation[,<span class="dv">2</span>], 
    <span class="dt">pch =</span> <span class="dv">16</span>, 
    <span class="dt">col =</span> cell_colors[<span class="kw">as.factor</span>(celltype_labs)]
) </code></pre></div>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># calculate loadings for components 1 and 2</span>
score &lt;-<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">abs</span>(pca<span class="op">$</span>x[,<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)])) 
<span class="kw">names</span>(score) &lt;-<span class="st"> </span><span class="kw">rownames</span>(expr_matrix)
score &lt;-<span class="st"> </span>score[<span class="kw">order</span>(<span class="op">-</span>score)]
PCA_genes &lt;-<span class="st"> </span><span class="kw">names</span>(score[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
<p><strong>Exercise 4</strong> Consider the top 5 principal components. Which appear to be most biologically relevant? How does the top 1,500 features change if you consider the loadings for those components?</p>
</div>
<div id="comparing-methods" class="section level3">
<h3><span class="header-section-number">8.3.3</span> Comparing Methods</h3>
<p>We can check whether the identified features really do represent genes differentially expressed between cell-types in this dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">M3DropExpressionHeatmap</span>(
    M3Drop_genes,
    expr_matrix,
    <span class="dt">cell_labels =</span> celltype_labs
)</code></pre></div>
<p><img src="26-dropouts_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can also consider how consistent each feature selection method is with the others using the Jaccard Index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">J &lt;-<span class="st"> </span><span class="kw">sum</span>(M3Drop_genes <span class="op">%in%</span><span class="st"> </span>HVG_genes)<span class="op">/</span><span class="kw">length</span>(<span class="kw">unique</span>(<span class="kw">c</span>(M3Drop_genes, HVG_genes)))</code></pre></div>
<p><strong>Exercise 5</strong></p>
<p>Plot the expression of the features for each of the other methods. Which appear to be differentially expressed? How consistent are the different methods for this dataset?</p>
</div>
<div id="sessioninfo-6" class="section level3">
<h3><span class="header-section-number">8.3.4</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] SingleCellExperiment_1.0.0 SummarizedExperiment_1.8.1
##  [3] DelayedArray_0.4.1         Biobase_2.38.0            
##  [5] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
##  [7] IRanges_2.12.0             S4Vectors_0.16.0          
##  [9] BiocGenerics_0.24.0        RColorBrewer_1.1-2        
## [11] M3Drop_3.05.00             numDeriv_2016.8-1         
## [13] matrixStats_0.53.1         scRNA.seq.funcs_0.1.0     
## [15] knitr_1.20                
## 
## loaded via a namespace (and not attached):
##  [1] splines_3.4.3          elliptic_1.3-7         gtools_3.5.0          
##  [4] Formula_1.2-2          moments_0.14           statmod_1.4.30        
##  [7] latticeExtra_0.6-28    GenomeInfoDbData_1.0.0 yaml_2.1.17           
## [10] pillar_1.2.1           backports_1.1.2        lattice_0.20-34       
## [13] bbmle_1.0.20           digest_0.6.15          XVector_0.18.0        
## [16] checkmate_1.8.5        colorspace_1.3-2       htmltools_0.3.6       
## [19] Matrix_1.2-7.1         plyr_1.8.4             bookdown_0.7          
## [22] zlibbioc_1.24.0        scales_0.5.0           gdata_2.18.0          
## [25] Rtsne_0.13             htmlTable_1.11.2       tibble_1.4.2          
## [28] mgcv_1.8-23            ggplot2_2.2.1          nnet_7.3-12           
## [31] lazyeval_0.2.1         survival_2.40-1        magrittr_1.5          
## [34] evaluate_0.10.1        nlme_3.1-129           MASS_7.3-45           
## [37] gplots_3.0.1           foreign_0.8-67         reldist_1.6-6         
## [40] tools_3.4.3            data.table_1.10.4-3    stringr_1.3.0         
## [43] munsell_0.4.3          cluster_2.0.6          irlba_2.3.2           
## [46] orthopolynom_1.0-5     compiler_3.4.3         caTools_1.17.1        
## [49] contfrac_1.1-11        rlang_0.2.0            grid_3.4.3            
## [52] RCurl_1.95-4.10        rstudioapi_0.7         htmlwidgets_1.0       
## [55] bitops_1.0-6           base64enc_0.1-3        rmarkdown_1.8         
## [58] hypergeo_1.2-13        gtable_0.2.0           deSolve_1.20          
## [61] gridExtra_2.3          Hmisc_4.1-1            rprojroot_1.3-2       
## [64] KernSmooth_2.23-15     stringi_1.1.6          Rcpp_0.12.15          
## [67] rpart_4.1-10           acepack_1.4.1          xfun_0.1</code></pre>

</div>
</div>
<div id="pseudotime-analysis" class="section level2">
<h2><span class="header-section-number">8.4</span> Pseudotime analysis</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(TSCAN)
<span class="kw">library</span>(M3Drop)
<span class="kw">library</span>(monocle)
<span class="kw">library</span>(destiny)
<span class="kw">library</span>(SLICER)
<span class="kw">library</span>(ouija)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(ggthemes)
<span class="kw">library</span>(ggbeeswarm)
<span class="kw">library</span>(corrplot)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<p>In many situations, one is studying a process where cells change continuously. This includes, for example, many differentiation processes taking place during development: following a stimulus, cells will change from one cell-type to another. Ideally, we would like to monitor the expression levels of an individual cell over time. Unfortunately, such monitoring is not possible with scRNA-seq since the cell is lysed (destroyed) when the RNA is extracted.</p>
<p>Instead, we must sample at multiple time-points and obtain snapshots of the gene expression profiles. Since some of the cells will proceed faster along the differentiation than others, each snapshot may contain cells at varying points along the developmental progression. We use statistical methods to order the cells along one or more trajectories which represent the underlying developmental trajectories, this ordering is referred to as “pseudotime”.</p>
<p>In this chapter we will consider five different tools: Monocle, TSCAN, destiny, SLICER and ouija for ordering cells according to their pseudotime development. To illustrate the methods we will be using a dataset on mouse embryonic development <span class="citation">(Deng et al. <a href="#ref-Deng2014-mx">2014</a>)</span>. The dataset consists of 268 cells from 10 different time-points of early mouse development. In this case, there is no need for pseudotime alignment since the cell labels provide information about the development trajectory. Thus, the labels allow us to establish a ground truth so that we can evaluate and compare the different methods.</p>
<p>A recent review by Cannoodt et al provides a detailed summary of the various computational methods for trajectory inference from single-cell transcriptomics <span class="citation">(Cannoodt, Saelens, and Saeys <a href="#ref-Cannoodt2016-uj">2016</a>)</span>. They discuss several tools, but unfortunately for our purposes many of these tools do not have complete or well-maintained implementations, and/or are not implemented in R.</p>
<p>Cannoodt et al cover:</p>
<ul>
<li>SCUBA - Matlab implementation</li>
<li>Wanderlust - Matlab (and requires registration to even download)</li>
<li>Wishbone - Python</li>
<li>SLICER - R, but package only available on Github</li>
<li>SCOUP - C++ command line tool</li>
<li>Waterfall - R, but one R script in supplement</li>
<li>Mpath - R pkg, but available as tar.gz on Github; function documentation but no vignette/workflow</li>
<li>Monocle - Bioconductor package</li>
<li>TSCAN - Bioconductor package</li>
</ul>
<p>Unfortunately only two tools discussed (Monocle and TSCAN) meet the gold standard of open-source software hosted in a reputable repository.</p>
<p>The following figures from the paper summarise some of the features of the various tools.</p>
<div class="figure" style="text-align: center"><span id="fig:pseudotime-methods-description"></span>
<img src="figures/cannoodt_pseudotime_properties.png" alt="Descriptions of trajectory inference methods for single-cell transcriptomics data (Fig. 2 from Cannoodt et al, 2016)." width="90%" />
<p class="caption">
Figure 8.10: Descriptions of trajectory inference methods for single-cell transcriptomics data (Fig. 2 from Cannoodt et al, 2016).
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:pseudotime-methods"></span>
<img src="figures/cannoodt_pseudotime_methods.png" alt="Characterization of trajectory inference methods for single-cell transcriptomics data (Fig. 3 from Cannoodt et al, 2016)." width="90%" />
<p class="caption">
Figure 8.11: Characterization of trajectory inference methods for single-cell transcriptomics data (Fig. 3 from Cannoodt et al, 2016).
</p>
</div>
<div id="first-look-at-deng-data" class="section level3">
<h3><span class="header-section-number">8.4.1</span> First look at Deng data</h3>
<p>Let us take a first look at the Deng data, without yet applying sophisticated pseudotime methods. As the plot below shows, simple PCA does a very good job of displaying the structure in these data. It is only once we reach the blast cell types (“earlyblast”, “midblast”, “lateblast”) that PCA struggles to separate the distinct cell types.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_SCE &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
deng_SCE<span class="op">$</span>cell_type2 &lt;-<span class="st"> </span><span class="kw">factor</span>(
    deng_SCE<span class="op">$</span>cell_type2,
    <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;zy&quot;</span>, <span class="st">&quot;early2cell&quot;</span>, <span class="st">&quot;mid2cell&quot;</span>, <span class="st">&quot;late2cell&quot;</span>,
                        <span class="st">&quot;4cell&quot;</span>, <span class="st">&quot;8cell&quot;</span>, <span class="st">&quot;16cell&quot;</span>, <span class="st">&quot;earlyblast&quot;</span>,
                        <span class="st">&quot;midblast&quot;</span>, <span class="st">&quot;lateblast&quot;</span>)
)
cellLabels &lt;-<span class="st"> </span>deng_SCE<span class="op">$</span>cell_type2
deng &lt;-<span class="st"> </span><span class="kw">counts</span>(deng_SCE)
<span class="kw">colnames</span>(deng) &lt;-<span class="st"> </span>cellLabels
deng_SCE &lt;-<span class="st"> </span><span class="kw">plotPCA</span>(deng_SCE, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, 
                    <span class="dt">return_SCE =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/data-overview-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>PCA, here, provides a useful baseline for assessing different pseudotime methods. For a very naive pseudotime we can just take the co-ordinates of the first principal component.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_SCE<span class="op">$</span>PC1 &lt;-<span class="st"> </span><span class="kw">reducedDim</span>(deng_SCE, <span class="st">&quot;PCA&quot;</span>)[,<span class="dv">1</span>]
<span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), <span class="kw">aes</span>(<span class="dt">x =</span> PC1, <span class="dt">y =</span> cell_type2, 
                              <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;First principal component&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cells ordered by first principal component&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/pca-pseudotime-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As the plot above shows, PC1 struggles to correctly order cells early and late in the developmental timecourse, but overall does a relatively good job of ordering cells by developmental time.</p>
<p>Can bespoke pseudotime methods do better than naive application of PCA?</p>
</div>
<div id="tscan" class="section level3">
<h3><span class="header-section-number">8.4.2</span> TSCAN</h3>
<p>TSCAN combines clustering with pseudotime analysis. First it clusters the cells using <code>mclust</code>, which is based on a mixture of normal distributions. Then it builds a minimum spanning tree to connect the clusters. The branch of this tree that connects the largest number of clusters is the main branch which is used to determine pseudotime.</p>
<p>First we will try to use all genes to order the cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">procdeng &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">preprocess</span>(deng)
<span class="kw">colnames</span>(procdeng) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(deng)
dengclust &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">exprmclust</span>(procdeng, <span class="dt">clusternum =</span> <span class="dv">10</span>)
TSCAN<span class="op">::</span><span class="kw">plotmclust</span>(dengclust)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/tscan-all-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dengorderTSCAN &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">TSCANorder</span>(dengclust, <span class="dt">orderonly =</span> <span class="ot">FALSE</span>)
pseudotime_order_tscan &lt;-<span class="st"> </span><span class="kw">as.character</span>(dengorderTSCAN<span class="op">$</span>sample_name)
deng_SCE<span class="op">$</span>pseudotime_order_tscan &lt;-<span class="st"> </span><span class="ot">NA</span>
deng_SCE<span class="op">$</span>pseudotime_order_tscan[<span class="kw">as.numeric</span>(dengorderTSCAN<span class="op">$</span>sample_name)] &lt;-<span class="st"> </span>
<span class="st">    </span>dengorderTSCAN<span class="op">$</span>Pseudotime</code></pre></div>
<p>Frustratingly, TSCAN only provides pseudotime values for 221 of 268 cells, silently returning missing values for non-assigned cells.</p>
<p>Again, we examine which timepoints have been assigned to each state:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cellLabels[dengclust<span class="op">$</span>clusterid <span class="op">==</span><span class="st"> </span><span class="dv">10</span>]</code></pre></div>
<pre><code>##  [1] late2cell late2cell late2cell late2cell late2cell late2cell late2cell
##  [8] late2cell late2cell late2cell
## 10 Levels: zy early2cell mid2cell late2cell 4cell 8cell ... lateblast</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> pseudotime_order_tscan, 
           <span class="dt">y =</span> cell_type2, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;TSCAN pseudotime&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cells ordered by TSCAN pseudotime&quot;</span>)</code></pre></div>
<pre><code>## Warning: Removed 47 rows containing missing values (position_quasirandom).</code></pre>
<p><img src="27-pseudotime_files/figure-html/tscan-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>TSCAN gets the development trajectory the “wrong way around”, in the sense that later pseudotime values correspond to early timepoints and vice versa. This is not inherently a problem (it is easy enough to reverse the ordering to get the intuitive interpretation of pseudotime), but overall it would be a stretch to suggest that TSCAN performs better than PCA on this dataset. (As it is a PCA-based method, perhaps this is not entirely surprising.)</p>
<p><strong>Exercise 1</strong> Compare results for different numbers of clusters (<code>clusternum</code>).</p>
</div>
<div id="monocle" class="section level3">
<h3><span class="header-section-number">8.4.3</span> monocle</h3>
<p>Monocle skips the clustering stage of TSCAN and directly builds a minimum spanning tree on a reduced dimension representation of the cells to connect all cells. Monocle then identifies the longest path in this tree to determine pseudotime. If the data contains diverging trajectories (i.e. one cell type differentiates into two different cell-types), monocle can identify these. Each of the resulting forked paths is defined as a separate cell state.</p>
<p>Unfortunately, Monocle does not work when all the genes are used, so we must carry out feature selection. First, we use M3Drop:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m3dGenes &lt;-<span class="st"> </span><span class="kw">as.character</span>(
    <span class="kw">M3DropFeatureSelection</span>(deng)<span class="op">$</span>Gene
)</code></pre></div>
<pre><code>## Warning in bg__calc_variables(expr_mat): Warning: Removing 1134 undetected
## genes.</code></pre>
<p><img src="27-pseudotime_files/figure-html/m3d-select-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d &lt;-<span class="st"> </span>deng[<span class="kw">which</span>(<span class="kw">rownames</span>(deng) <span class="op">%in%</span><span class="st"> </span>m3dGenes), ]
d &lt;-<span class="st"> </span>d[<span class="op">!</span><span class="kw">duplicated</span>(<span class="kw">rownames</span>(d)), ]</code></pre></div>
<p>Now run monocle:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colnames</span>(d) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(d)
geneNames &lt;-<span class="st"> </span><span class="kw">rownames</span>(d)
<span class="kw">rownames</span>(d) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(d)
pd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">timepoint =</span> cellLabels)
pd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data=</span>pd)
fd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">gene_short_name =</span> geneNames)
fd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data=</span>fd)

dCellData &lt;-<span class="st"> </span><span class="kw">newCellDataSet</span>(d, <span class="dt">phenoData =</span> pd, <span class="dt">featureData =</span> fd, <span class="dt">expressionFamily =</span> <span class="kw">tobit</span>())
dCellData &lt;-<span class="st"> </span><span class="kw">setOrderingFilter</span>(dCellData, <span class="kw">which</span>(geneNames <span class="op">%in%</span><span class="st"> </span>m3dGenes))
dCellData &lt;-<span class="st"> </span><span class="kw">estimateSizeFactors</span>(dCellData)
dCellDataSet &lt;-<span class="st"> </span><span class="kw">reduceDimension</span>(dCellData, <span class="dt">pseudo_expr =</span> <span class="dv">1</span>)
dCellDataSet &lt;-<span class="st"> </span><span class="kw">orderCells</span>(dCellDataSet, <span class="dt">reverse =</span> <span class="ot">FALSE</span>)
<span class="kw">plot_cell_trajectory</span>(dCellDataSet)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/monocle-all-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Store the ordering</span>
pseudotime_monocle &lt;-
<span class="st">    </span><span class="kw">data.frame</span>(
        <span class="dt">Timepoint =</span> <span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>timepoint,
        <span class="dt">pseudotime =</span> <span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>Pseudotime,
        <span class="dt">State =</span> <span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>State
    )
<span class="kw">rownames</span>(pseudotime_monocle) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(d)
pseudotime_order_monocle &lt;-
<span class="st">    </span><span class="kw">rownames</span>(pseudotime_monocle[<span class="kw">order</span>(pseudotime_monocle<span class="op">$</span>pseudotime), ])</code></pre></div>
<p>We can again compare the inferred pseudotime to the known sampling timepoints.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_SCE<span class="op">$</span>pseudotime_monocle &lt;-<span class="st"> </span>pseudotime_monocle<span class="op">$</span>pseudotime
<span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> pseudotime_monocle, 
           <span class="dt">y =</span> cell_type2, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;monocle pseudotime&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cells ordered by monocle pseudotime&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/monocle-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Monocle - at least with its default settings - performs poorly on these data. The “late2cell” group is completely separated from the “zy”, “early2cell” and “mid2cell” cells (though these are correctly ordered), and there is no separation at all of “4cell”, “8cell”, “16cell” or any blast cell groups.</p>
</div>
<div id="diffusion-maps" class="section level3">
<h3><span class="header-section-number">8.4.4</span> Diffusion maps</h3>
<p><a href="https://en.wikipedia.org/wiki/Diffusion_map">Diffusion maps</a> were introduced by <a href="http://www.sciencedirect.com/science/article/pii/S1063520306000546">Ronald Coifman and Stephane Lafon</a>, and the underlying idea is to assume that the data are samples from a diffusion process. The method infers the low-dimensional manifold by estimating the eigenvalues and eigenvectors for the diffusion operator related to the data.</p>
<p><a href="http://biorxiv.org/content/biorxiv/early/2015/08/04/023309.full.pdf">Haghverdi et al</a> have applied the diffusion maps concept to the analysis of single-cell RNA-seq data to create an R package called <a href="http://bioconductor.org/packages/destiny">destiny</a>.</p>
<p>We will take the ranko prder of cells in the first diffusion map component as “diffusion map pseudotime” here.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">logcounts</span>(deng_SCE)
<span class="kw">colnames</span>(deng) &lt;-<span class="st"> </span>cellLabels
dm &lt;-<span class="st"> </span><span class="kw">DiffusionMap</span>(<span class="kw">t</span>(deng))

tmp &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">DC1 =</span> <span class="kw">eigenvectors</span>(dm)[,<span class="dv">1</span>],
                  <span class="dt">DC2 =</span> <span class="kw">eigenvectors</span>(dm)[,<span class="dv">2</span>],
                  <span class="dt">Timepoint =</span> deng_SCE<span class="op">$</span>cell_type2)
<span class="kw">ggplot</span>(tmp, <span class="kw">aes</span>(<span class="dt">x =</span> DC1, <span class="dt">y =</span> DC2, <span class="dt">colour =</span> Timepoint)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;Diffusion component 1&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">ylab</span>(<span class="st">&quot;Diffusion component 2&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_classic</span>()</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/destiny-deng-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_SCE<span class="op">$</span>pseudotime_diffusionmap &lt;-<span class="st"> </span><span class="kw">rank</span>(<span class="kw">eigenvectors</span>(dm)[,<span class="dv">1</span>])
<span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> pseudotime_diffusionmap, 
           <span class="dt">y =</span> cell_type2, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;Diffusion map pseudotime (first diffusion map component)&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cells ordered by diffusion map pseudotime&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/destiny-deng-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Like the other methods, using the first diffusion map component from destiny as pseudotime does a good job at ordering the early time-points (if we take high values as “earlier” in developement), but it is unable to distinguish the later ones.</p>
<p><strong>Exercise 2</strong> Do you get a better resolution between the later time points by considering additional eigenvectors?</p>
<p><strong>Exercise 3</strong> How does the ordering change if you only use the genes identified by M3Drop?</p>
</div>
<div id="slicer" class="section level3">
<h3><span class="header-section-number">8.4.5</span> SLICER</h3>
<p>The SLICER method is an algorithm for constructing trajectories that describe gene expression changes during a sequential biological process, just as Monocle and TSCAN are. SLICER is designed to capture highly nonlinear gene expression changes, automatically select genes related to the process, and detect multiple branch and loop features in the trajectory <span class="citation">(Welch, Hartemink, and Prins <a href="#ref-Welch2016-jr">2016</a>)</span>. The SLICER R package is available from its <a href="https://github.com/jw156605/SLICER">GitHub repository</a> and can be installed from there using the <code>devtools</code> package.</p>
<p>We use the <code>select_genes</code> function in SLICER to automatically select the genes to use in builing the cell trajectory. The function uses “neighbourhood variance” to identify genes that vary smoothly, rather than fluctuating randomly, across the set of cells. Following this, we determine which value of “k” (number of nearest neighbours) yields an embedding that most resembles a trajectory. Then we estimate the <a href="https://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction">locally linear embedding</a> of the cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;lle&quot;</span>)
slicer_genes &lt;-<span class="st"> </span><span class="kw">select_genes</span>(<span class="kw">t</span>(deng))
k &lt;-<span class="st"> </span><span class="kw">select_k</span>(<span class="kw">t</span>(deng[slicer_genes,]), <span class="dt">kmin =</span> <span class="dv">30</span>, <span class="dt">kmax=</span><span class="dv">60</span>)</code></pre></div>
<pre><code>## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">slicer_traj_lle &lt;-<span class="st"> </span><span class="kw">lle</span>(<span class="kw">t</span>(deng[slicer_genes,]), <span class="dt">m =</span> <span class="dv">2</span>, k)<span class="op">$</span>Y</code></pre></div>
<pre><code>## finding neighbours
## calculating weights
## computing coordinates</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reducedDim</span>(deng_SCE, <span class="st">&quot;LLE&quot;</span>) &lt;-<span class="st"> </span>slicer_traj_lle
<span class="kw">plotReducedDim</span>(deng_SCE, <span class="dt">use_dimred =</span> <span class="st">&quot;LLE&quot;</span>, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;LLE component 1&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;LLE component 2&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ggtitle</span>(<span class="st">&quot;Locally linear embedding of cells from SLICER&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/slicer-analyis-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>With the locally linear embedding computed we can construct a k-nearest neighbour graph that is fully connected. This plot displays a (yellow) circle for each cell, with the cell ID number overlaid in blue. Here we show the graph computed using 10 nearest neighbours. Here, SLICER appears to detect one major trajectory with one branch.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">slicer_traj_graph &lt;-<span class="st"> </span><span class="kw">conn_knn_graph</span>(slicer_traj_lle, <span class="dv">10</span>)
<span class="kw">plot</span>(slicer_traj_graph, <span class="dt">main =</span> <span class="st">&quot;Fully connected kNN graph from SLICER&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/slicer-build-graph-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>From this graph we can identify “extreme” cells that are candidates for start/end cells in the trajectory.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ends &lt;-<span class="st"> </span><span class="kw">find_extreme_cells</span>(slicer_traj_graph, slicer_traj_lle)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/slicer-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start &lt;-<span class="st"> </span>ends[<span class="dv">1</span>]</code></pre></div>
<p>Having defined a start cell we can order the cells in the estimated pseudotime.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pseudotime_order_slicer &lt;-<span class="st"> </span><span class="kw">cell_order</span>(slicer_traj_graph, start)
branches &lt;-<span class="st"> </span><span class="kw">assign_branches</span>(slicer_traj_graph, start)

pseudotime_slicer &lt;-
<span class="st">    </span><span class="kw">data.frame</span>(
        <span class="dt">Timepoint =</span> cellLabels,
        <span class="dt">pseudotime =</span> <span class="ot">NA</span>,
        <span class="dt">State =</span> branches
    )
pseudotime_slicer<span class="op">$</span>pseudotime[pseudotime_order_slicer] &lt;-
<span class="st">    </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(pseudotime_order_slicer)
deng_SCE<span class="op">$</span>pseudotime_slicer &lt;-<span class="st"> </span>pseudotime_slicer<span class="op">$</span>pseudotime</code></pre></div>
<p>We can again compare the inferred pseudotime to the known sampling timepoints. SLICER does not provide a pseudotime value per se, just an ordering of cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> pseudotime_slicer, 
           <span class="dt">y =</span> cell_type2, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;SLICER pseudotime (cell ordering)&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_classic</span>()</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/slicer-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Like the previous method, SLICER here provides a good ordering for the early time points. It places “16cell” cells before “8cell” cells, but provides better ordering for blast cells than many of the earlier methods.</p>
<p><strong>Exercise 4</strong> How do the results change for different k? (e.g. k = 5) What about changing the number of nearest neighbours in the call to <code>conn_knn_graph</code>?</p>
<p><strong>Exercise 5</strong> How does the ordering change if you use a different set of genes from those chosen by SLICER (e.g. the genes identified by M3Drop)?</p>
</div>
<div id="ouija" class="section level3">
<h3><span class="header-section-number">8.4.6</span> Ouija</h3>
<p>Ouija (<a href="http://kieranrcampbell.github.io/ouija/" class="uri">http://kieranrcampbell.github.io/ouija/</a>) takes a different approach from the pseudotime estimation methods we have looked at so far. Earlier methods have all been “unsupervised”, which is to say that apart from perhaps selecting informative genes we do not supply the method with any prior information about how we expect certain genes or the trajectory as a whole to behave.</p>
<p>Ouija, in contrast, is a probabilistic framework that allows for interpretable learning of single-cell pseudotimes using only small panels of marker genes. This method:</p>
<ul>
<li>infers pseudotimes from a small number of marker genes letting you understand why the pseudotimes have been learned in terms of those genes;</li>
<li>provides parameter estimates (with uncertainty) for interpretable gene regulation behaviour (such as the peak time or the upregulation time);</li>
<li>has a Bayesian hypothesis test to find genes regulated before others along the trajectory;</li>
<li>identifies metastable states, ie discrete cell types along the continuous trajectory.</li>
</ul>
<p>We will supply the following marker genes to Ouija (with timepoints where they are expected to be highly expressed):</p>
<ul>
<li>Early timepoints: Dazl, Rnf17, Sycp3, Nanog, Pou5f1, Fgf8, Egfr, Bmp5, Bmp15</li>
<li>Mid timepoints: Zscan4b, Foxa1, Prdm14, Sox21</li>
<li>Late timepoints: Creb3, Gpx4, Krt8, Elf5, Eomes, Cdx2, Tdgf1, Gdf3</li>
</ul>
<p>With Ouija we can model genes as either exhibiting monotonic up or down regulation (known as switch-like behaviour), or transient behaviour where the gene briefly peaks. By default, Ouija assumes all genes exhibit switch-like behaviour (the authors assure us not to worry if we get it wrong - the noise model means incorrectly specifying a transient gene as switch-like has minimal effect).</p>
<p>Here we can “cheat” a little and check that our selected marker genes do actually identify different timepoints of the differentiation process.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ouija_markers_down &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Dazl&quot;</span>, <span class="st">&quot;Rnf17&quot;</span>, <span class="st">&quot;Sycp3&quot;</span>, <span class="st">&quot;Fgf8&quot;</span>, 
                        <span class="st">&quot;Egfr&quot;</span>, <span class="st">&quot;Bmp5&quot;</span>, <span class="st">&quot;Bmp15&quot;</span>, <span class="st">&quot;Pou5f1&quot;</span>)
ouija_markers_up &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Creb3&quot;</span>, <span class="st">&quot;Gpx4&quot;</span>, <span class="st">&quot;Krt8&quot;</span>, <span class="st">&quot;Elf5&quot;</span>, <span class="st">&quot;Cdx2&quot;</span>, 
                      <span class="st">&quot;Tdgf1&quot;</span>, <span class="st">&quot;Gdf3&quot;</span>, <span class="st">&quot;Eomes&quot;</span>)
ouija_markers_transient &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Zscan4b&quot;</span>, <span class="st">&quot;Foxa1&quot;</span>, <span class="st">&quot;Prdm14&quot;</span>, <span class="st">&quot;Sox21&quot;</span>)
ouija_markers &lt;-<span class="st"> </span><span class="kw">c</span>(ouija_markers_down, ouija_markers_up, 
                   ouija_markers_transient)
<span class="kw">plotExpression</span>(deng_SCE, ouija_markers, <span class="dt">x =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme</span>(<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">angle =</span> <span class="dv">60</span>, <span class="dt">hjust =</span> <span class="dv">1</span>))</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-response-type-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>In order to fit the pseudotimes wesimply call <code>ouija</code>, passing in the expected response types. Note that if no response types are provided then they are all assumed to be switch-like by default, which we will do here. The input to Ouija can be a cell-by-gene matrix of non-negative expression values, or an ExpressionSet object, or, happily, by selecting the <code>logcounts</code> values from a SingleCellExperiment object.</p>
<p>We can apply prior information about whether genes are up- or down-regulated across the differentiation process, and also provide prior information about when the switch in expression or a peak in expression is likely to occur.</p>
<p>We can fit the Ouija model using either:</p>
<ul>
<li>Hamiltonian Monte Carlo (HMC) - full MCMC inference where gradient information of the log-posterior is used to “guide” the random walk through the parameter space, or</li>
<li>Automatic Differentiation Variational Bayes (ADVI or simply VI) - approximate inference where the KL divergence to an approximate distribution is minimised.</li>
</ul>
<p>In general, HMC will provide more accurate inference with approximately correct posterior variance for all parameters. However, VB is orders of magnitude quicker than HMC and while it may underestimate posterior variance, the Ouija authors suggest that anecdotally it often performs as well as HMC for discovering posterior pseudotimes.</p>
<p>To help the Ouija model, we provide it with prior information about the strength of switches for up- and down-regulated genes. By setting switch strength to -10 for down-regulated genes and 10 for up-regulated genes with a prior strength standard deviation of 0.5 we are telling the model that we are confident about the expected behaviour of these genes across the differentiation process.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">mc.cores =</span> parallel<span class="op">::</span><span class="kw">detectCores</span>())
response_type &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;switch&quot;</span>, <span class="kw">length</span>(ouija_markers_down) <span class="op">+</span><span class="st"> </span>
<span class="st">                           </span><span class="kw">length</span>(ouija_markers_up)), 
                   <span class="kw">rep</span>(<span class="st">&quot;transient&quot;</span>, <span class="kw">length</span>(ouija_markers_transient)))
switch_strengths &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="op">-</span><span class="dv">10</span>, <span class="kw">length</span>(ouija_markers_down)),
                      <span class="kw">rep</span>(<span class="dv">10</span>, <span class="kw">length</span>(ouija_markers_up)))
switch_strength_sd &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="fl">0.5</span>, <span class="kw">length</span>(ouija_markers_down)),
                      <span class="kw">rep</span>(<span class="fl">0.5</span>, <span class="kw">length</span>(ouija_markers_up)))
garbage &lt;-<span class="st"> </span><span class="kw">capture.output</span>(
    oui_vb &lt;-<span class="st"> </span><span class="kw">ouija</span>(deng_SCE[ouija_markers,],
                    <span class="dt">single_cell_experiment_assay =</span> <span class="st">&quot;logcounts&quot;</span>, 
                    <span class="dt">response_type =</span> response_type,
                    <span class="dt">switch_strengths =</span> switch_strengths,
                    <span class="dt">switch_strength_sd =</span> switch_strength_sd,
                    <span class="dt">inference_type =</span> <span class="st">&quot;vb&quot;</span>)
)

<span class="kw">print</span>(oui_vb)</code></pre></div>
<pre><code>## A Ouija fit with 268 cells and 20 marker genes 
## Inference type:  Variational Bayes 
## (Gene behaviour) Switch/transient: 16 / 4</code></pre>
<p>We can plot the gene expression over pseudotime along with the maximum a posteriori (MAP) estimates of the mean function (the sigmoid or Gaussian transient function) using the plot_expression function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot_expression</span>(oui_vb)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-plot-exprs-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can also visualise when in the trajectory gene regulation behaviour occurs, either in the form of the switch time or the peak time (for switch-like or transient genes) using the plot_switch_times and plot_transient_times functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot_switch_times</span>(oui_vb)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-plot-switch-times-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot_peak_times</span>(oui_vb)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-plot-switch-times-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Identify metastable states using consistency matrices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cmo &lt;-<span class="st"> </span><span class="kw">consistency_matrix</span>(oui_vb)
<span class="kw">plot_consistency</span>(oui_vb)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-consistency-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cell_classifications &lt;-<span class="st"> </span><span class="kw">cluster_consistency</span>(cmo)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">map_pst &lt;-<span class="st"> </span><span class="kw">map_pseudotime</span>(oui_vb)
ouija_pseudotime &lt;-<span class="st"> </span><span class="kw">data.frame</span>(map_pst, cell_classifications)

<span class="kw">ggplot</span>(ouija_pseudotime, <span class="kw">aes</span>(<span class="dt">x =</span> map_pst, <span class="dt">y =</span> cell_classifications)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;MAP pseudotime&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Cell classification&quot;</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-pseudotime-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_SCE<span class="op">$</span>pseudotime_ouija &lt;-<span class="st"> </span>ouija_pseudotime<span class="op">$</span>map_pst
deng_SCE<span class="op">$</span>ouija_cell_class &lt;-<span class="st"> </span>ouija_pseudotime<span class="op">$</span>cell_classifications

<span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> pseudotime_ouija, 
           <span class="dt">y =</span> cell_type2, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_quasirandom</span>(<span class="dt">groupOnX =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;Ouija pseudotime&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylab</span>(<span class="st">&quot;Timepoint&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_classic</span>()</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-pseudotime-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Ouija does quite well in the ordering of the cells here, although it can be sensitive to the choice of marker genes and prior information supplied. How do the results change if you select different marker genes or change the priors?</p>
<p>Ouija identifies four metastable states here, which we might annotate as “zygote/2cell”, “4/8/16 cell”, “blast1” and “blast2”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="kw">as.data.frame</span>(<span class="kw">colData</span>(deng_SCE)), 
       <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">as.factor</span>(ouija_cell_class), 
           <span class="dt">y =</span> pseudotime_ouija, <span class="dt">colour =</span> cell_type2)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">coord_flip</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;Ouija cell classification&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">ylab</span>(<span class="st">&quot;Ouija pseudotime&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">theme_classic</span>()</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/ouija-states-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>A common analysis is to work out the regulation orderings of genes. For example, is gene A upregulated before gene B? Does gene C peak before the downregulation of gene D? Ouija answers these questions in terms of a Bayesian hypothesis test of whether the difference in regulation timing (either switch time or peak time) is significantly different to 0. This is collated using the gene_regulation function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gene_regs &lt;-<span class="st"> </span><span class="kw">gene_regulation</span>(oui_vb)
<span class="kw">head</span>(gene_regs)</code></pre></div>
<pre><code>## # A tibble: 6 x 7
## # Groups:   label, gene_A [6]
##   label        gene_A gene_B mean_difference lower_95 upper_95 significant
##   &lt;chr&gt;        &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;lgl&gt;      
## 1 Bmp15 - Cdx2 Bmp15  Cdx2           -0.0434 -0.0912   0.0110  FALSE      
## 2 Bmp15 - Cre… Bmp15  Creb3           0.278   0.220    0.330   TRUE       
## 3 Bmp15 - Elf5 Bmp15  Elf5           -0.656  -0.688   -0.618   TRUE       
## 4 Bmp15 - Eom… Bmp15  Eomes           0.0766  0.00433  0.153   TRUE       
## 5 Bmp15 - Fox… Bmp15  Foxa1          -0.0266 -0.0611   0.00287 FALSE      
## 6 Bmp15 - Gdf3 Bmp15  Gdf3            0.0704  0.00963  0.134   TRUE</code></pre>
<p>What conclusions can you draw from the gene regulation output from Ouija?</p>
<p>If you have time, you might try the HMC inference method and see if that changes the Ouija results in any way.</p>
</div>
<div id="comparison-of-the-methods" class="section level3">
<h3><span class="header-section-number">8.4.7</span> Comparison of the methods</h3>
<p>How do the trajectories inferred by TSCAN, Monocle, Diffusion Map, SLICER and Ouija compare?</p>
<p>TSCAN and Diffusion Map methods get the trajectory the “wrong way round”, so we’ll adjust that for these comparisons.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_pseudotime &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(
    <span class="kw">colData</span>(deng_SCE)[, <span class="kw">grep</span>(<span class="st">&quot;pseudotime&quot;</span>, <span class="kw">colnames</span>(<span class="kw">colData</span>(deng_SCE)))]
)
<span class="kw">colnames</span>(df_pseudotime) &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;pseudotime_&quot;</span>, <span class="st">&quot;&quot;</span>, 
                                <span class="kw">colnames</span>(df_pseudotime))
df_pseudotime<span class="op">$</span>PC1 &lt;-<span class="st"> </span>deng_SCE<span class="op">$</span>PC1
df_pseudotime<span class="op">$</span>order_tscan &lt;-<span class="st"> </span><span class="op">-</span>df_pseudotime<span class="op">$</span>order_tscan
df_pseudotime<span class="op">$</span>diffusionmap &lt;-<span class="st"> </span><span class="op">-</span>df_pseudotime<span class="op">$</span>diffusionmap

<span class="kw">corrplot.mixed</span>(<span class="kw">cor</span>(df_pseudotime, <span class="dt">use =</span> <span class="st">&quot;na.or.complete&quot;</span>), 
               <span class="dt">order =</span> <span class="st">&quot;hclust&quot;</span>, <span class="dt">tl.col =</span> <span class="st">&quot;black&quot;</span>,
               <span class="dt">main =</span> <span class="st">&quot;Correlation matrix for pseudotime results&quot;</span>,
               <span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">3.1</span>, <span class="dv">0</span>))</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/compare-results-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>We see here that Ouija, TSCAN and SLICER all give trajectories that are similar and strongly correlated with PC1. Diffusion Map is less strongly correlated with these methods, and Monocle gives very different results.</p>
<p><strong>Exercise 6</strong>: Compare destiny and SLICER to TSCAN, Monocle and Ouija in more depth. Where and how do they differ?</p>
</div>
<div id="expression-of-genes-through-time" class="section level3">
<h3><span class="header-section-number">8.4.8</span> Expression of genes through time</h3>
<p>Each package also enables the visualization of expression through pseudotime. Following individual genes is very helpful for identifying genes that play an important role in the differentiation process. We illustrate the procedure using the <code>Rhoa</code> gene.</p>
<p>We have added the pseudotime values computed with all methods here to the <code>colData</code> slot of an <code>SCE</code> object. Having done that, the full plotting capabilities of the <code>scater</code> package can be used to investigate relationships between gene expression, cell populations and pseudotime. This is particularly useful for the packages such as SLICER that do not provide plotting functions.</p>
<p><strong>Principal components</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;PC1&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-pc1-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>TSCAN</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;pseudotime_order_tscan&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-tscan-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Monocle</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;pseudotime_monocle&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-monocle-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Diffusion Map</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;pseudotime_diffusionmap&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-diff-map-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>SLICER</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;pseudotime_slicer&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-slicer-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Ouija</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotExpression</span>(deng_SCE, <span class="st">&quot;Rhoa&quot;</span>, <span class="dt">x =</span> <span class="st">&quot;pseudotime_ouija&quot;</span>, 
               <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>, <span class="dt">show_violin =</span> <span class="ot">FALSE</span>,
               <span class="dt">show_smooth =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="27-pseudotime_files/figure-html/Rhoa-ouija-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>How many of these methods outperform the naive approach of using the first principal component to represent pseudotime for these data?</p>
<p><strong>Exercise 7</strong>: Repeat the exercise using a subset of the genes, e.g. the set of highly variable genes that can be obtained using <code>Brennecke_getVariableGenes()</code></p>
</div>
<div id="sessioninfo-7" class="section level3">
<h3><span class="header-section-number">8.4.9</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
##  [1] splines   parallel  stats4    methods   stats     graphics  grDevices
##  [8] utils     datasets  base     
## 
## other attached packages:
##  [1] bindrcpp_0.2               rstan_2.17.3              
##  [3] StanHeaders_2.17.2         lle_1.1                   
##  [5] snowfall_1.84-6.1          snow_0.4-2                
##  [7] MASS_7.3-45                scatterplot3d_0.3-40      
##  [9] corrplot_0.84              ggbeeswarm_0.6.0          
## [11] ggthemes_3.4.0             scater_1.6.3              
## [13] ouija_0.99.0               Rcpp_0.12.15              
## [15] SLICER_0.2.0               destiny_2.6.1             
## [17] monocle_2.6.3              DDRTree_0.1.5             
## [19] irlba_2.3.2                VGAM_1.0-5                
## [21] ggplot2_2.2.1              Matrix_1.2-7.1            
## [23] M3Drop_3.05.00             numDeriv_2016.8-1         
## [25] TSCAN_1.16.0               SingleCellExperiment_1.0.0
## [27] SummarizedExperiment_1.8.1 DelayedArray_0.4.1        
## [29] matrixStats_0.53.1         Biobase_2.38.0            
## [31] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
## [33] IRanges_2.12.0             S4Vectors_0.16.0          
## [35] BiocGenerics_0.24.0        knitr_1.20                
## 
## loaded via a namespace (and not attached):
##   [1] utf8_1.1.3             shinydashboard_0.6.1   R.utils_2.6.0         
##   [4] tidyselect_0.2.4       lme4_1.1-15            RSQLite_2.0           
##   [7] AnnotationDbi_1.40.0   htmlwidgets_1.0        grid_3.4.3            
##  [10] combinat_0.0-8         Rtsne_0.13             munsell_0.4.3         
##  [13] codetools_0.2-15       statmod_1.4.30         colorspace_1.3-2      
##  [16] fastICA_1.2-1          highr_0.6              rstudioapi_0.7        
##  [19] robustbase_0.92-8      vcd_1.4-4              tensor_1.5            
##  [22] VIM_4.7.0              TTR_0.23-3             labeling_0.3          
##  [25] slam_0.1-42            splancs_2.01-40        tximport_1.6.0        
##  [28] bbmle_1.0.20           GenomeInfoDbData_1.0.0 polyclip_1.6-1        
##  [31] bit64_0.9-7            pheatmap_1.0.8         rhdf5_2.22.0          
##  [34] rprojroot_1.3-2        coda_0.19-1            xfun_0.1              
##  [37] R6_2.2.2               RcppEigen_0.3.3.4.0    locfit_1.5-9.1        
##  [40] bitops_1.0-6           spatstat.utils_1.8-0   assertthat_0.2.0      
##  [43] scales_0.5.0           nnet_7.3-12            beeswarm_0.2.3        
##  [46] gtable_0.2.0           goftest_1.1-1          rlang_0.2.0           
##  [49] MatrixModels_0.4-1     lazyeval_0.2.1         acepack_1.4.1         
##  [52] checkmate_1.8.5        inline_0.3.14          yaml_2.1.17           
##  [55] reshape2_1.4.3         abind_1.4-5            backports_1.1.2       
##  [58] httpuv_1.3.6.1         Hmisc_4.1-1            tensorA_0.36          
##  [61] tools_3.4.3            bookdown_0.7           cubature_1.3-11       
##  [64] gplots_3.0.1           RColorBrewer_1.1-2     proxy_0.4-21          
##  [67] MCMCglmm_2.25          plyr_1.8.4             progress_1.1.2        
##  [70] base64enc_0.1-3        zlibbioc_1.24.0        purrr_0.2.4           
##  [73] RCurl_1.95-4.10        densityClust_0.3       prettyunits_1.0.2     
##  [76] rpart_4.1-10           alphahull_2.1          deldir_0.1-14         
##  [79] reldist_1.6-6          viridis_0.5.0          cowplot_0.9.2         
##  [82] zoo_1.8-1              ggrepel_0.7.0          cluster_2.0.6         
##  [85] magrittr_1.5           data.table_1.10.4-3    SparseM_1.77          
##  [88] lmtest_0.9-35          RANN_2.5.1             mime_0.5              
##  [91] evaluate_0.10.1        xtable_1.8-2           XML_3.98-1.10         
##  [94] smoother_1.1           pbkrtest_0.4-7         mclust_5.4            
##  [97] gridExtra_2.3          biomaRt_2.34.2         HSMMSingleCell_0.112.0
## [100] compiler_3.4.3         tibble_1.4.2           crayon_1.3.4          
## [103] KernSmooth_2.23-15     minqa_1.2.4            R.oo_1.21.0           
## [106] htmltools_0.3.6        mgcv_1.8-23            corpcor_1.6.9         
## [109] Formula_1.2-2          tidyr_0.8.0            DBI_0.7               
## [112] boot_1.3-18            car_2.1-6              cli_1.0.0             
## [115] sgeostat_1.0-27        R.methodsS3_1.7.1      gdata_2.18.0          
## [118] bindr_0.1              igraph_1.1.2           pkgconfig_2.0.1       
## [121] foreign_0.8-67         laeken_0.4.6           sp_1.2-7              
## [124] vipor_0.4.5            XVector_0.18.0         stringr_1.3.0         
## [127] digest_0.6.15          spatstat.data_1.2-0    rmarkdown_1.8         
## [130] htmlTable_1.11.2       edgeR_3.20.9           curl_3.1              
## [133] shiny_1.0.5            gtools_3.5.0           quantreg_5.35         
## [136] rjson_0.2.15           nloptr_1.0.4           nlme_3.1-129          
## [139] viridisLite_0.3.0      limma_3.34.9           pillar_1.2.1          
## [142] lattice_0.20-34        httr_1.3.1             DEoptimR_1.0-8        
## [145] survival_2.40-1        glue_1.2.0             xts_0.10-1            
## [148] qlcMatrix_0.9.5        FNN_1.1                spatstat_1.55-0       
## [151] bit_1.1-12             class_7.3-14           stringi_1.1.6         
## [154] blob_1.1.0             memoise_1.1.0          latticeExtra_0.6-28   
## [157] caTools_1.17.1         dplyr_0.7.4            e1071_1.6-8           
## [160] ape_5.0                tripack_1.3-8</code></pre>

</div>
</div>
<div id="imputation" class="section level2">
<h2><span class="header-section-number">8.5</span> Imputation</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scImpute)
<span class="kw">library</span>(SC3)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(mclust)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>As discussed previously, one of the main challenges when analyzing scRNA-seq data is the presence of zeros, or dropouts. The dropouts are assumed to have arisen for three possible reasons:</p>
<ul>
<li>The gene was not expressed in the cell and hence there are no transcripts to sequence</li>
<li>The gene was expressed, but for some reason the transcripts were lost somewhere prior to sequencing</li>
<li>The gene was expressed and transcripts were captured and turned into cDNA, but the sequencing depth was not sufficient to produce any reads.</li>
</ul>
<p>Thus, dropouts could be result of experimental shortcomings, and if this is the case then we would like to provide computational corrections. One possible solution is to impute the dropouts in the expression matrix. To be able to impute gene expression values, one must have an underlying model. However, since we do not know which dropout events are technical artefacts and which correspond to the transcript being truly absent, imputation is a difficult challenge.</p>
<p>To the best of our knowledge, there are currently two different imputation methods available: <a href="https://github.com/pkathail/magic">MAGIC</a> <span class="citation">(Dijk et al. <a href="#ref-Van_Dijk2017-bh">2017</a>)</span> and <a href="https://github.com/Vivianstats/scImpute">scImpute</a> <span class="citation">(W. V. Li and Li <a href="#ref-Li2017-tz">2017</a>)</span>. MAGIC is only available for Python or Matlab, but we will run it from within R.</p>
<div id="scimpute" class="section level3">
<h3><span class="header-section-number">8.5.1</span> scImpute</h3>
<p>To test <code>scImpute</code>, we use the default parameters and we apply it to the Deng dataset that we have worked with before. scImpute takes a .csv or .txt file as an input:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
<span class="kw">write.csv</span>(<span class="kw">counts</span>(deng), <span class="st">&quot;deng.csv&quot;</span>)
<span class="kw">scimpute</span>(
    <span class="dt">count_path =</span> <span class="st">&quot;deng.csv&quot;</span>,
    <span class="dt">infile =</span> <span class="st">&quot;csv&quot;</span>,
    <span class="dt">outfile =</span> <span class="st">&quot;txt&quot;</span>, 
    <span class="dt">out_dir =</span> <span class="st">&quot;./&quot;</span>,
    <span class="dt">Kcluster =</span> <span class="dv">10</span>,
    <span class="dt">ncores =</span> <span class="dv">2</span>
)</code></pre></div>
<pre><code>## [1] &quot;reading in raw count matrix ...&quot;
## [1] &quot;number of genes in raw count matrix 22431&quot;
## [1] &quot;number of cells in raw count matrix 268&quot;
## [1] &quot;inferring cell similarities ...&quot;
## [1] &quot;cluster sizes:&quot;
##  [1] 12  9 26  5  9 57 58 43 17 22
## [1] &quot;estimating dropout probability for type 1 ...&quot;
## [1] &quot;imputing dropout values for type 1 ...&quot;
## [1] &quot;estimating dropout probability for type 2 ...&quot;
## [1] &quot;imputing dropout values for type 2 ...&quot;
## [1] &quot;estimating dropout probability for type 3 ...&quot;
## [1] &quot;imputing dropout values for type 3 ...&quot;
## [1] &quot;estimating dropout probability for type 4 ...&quot;
## [1] &quot;imputing dropout values for type 4 ...&quot;
## [1] &quot;estimating dropout probability for type 5 ...&quot;
## [1] &quot;imputing dropout values for type 5 ...&quot;
## [1] &quot;estimating dropout probability for type 6 ...&quot;
## [1] &quot;imputing dropout values for type 6 ...&quot;
## [1] &quot;estimating dropout probability for type 7 ...&quot;
## [1] &quot;imputing dropout values for type 7 ...&quot;
## [1] &quot;estimating dropout probability for type 8 ...&quot;
## [1] &quot;imputing dropout values for type 8 ...&quot;
## [1] &quot;estimating dropout probability for type 9 ...&quot;
## [1] &quot;imputing dropout values for type 9 ...&quot;
## [1] &quot;estimating dropout probability for type 10 ...&quot;
## [1] &quot;imputing dropout values for type 10 ...&quot;
## [1] &quot;writing imputed count matrix ...&quot;</code></pre>
<pre><code>##  [1]  17  18  88 111 126 177 186 229 244 247</code></pre>
<p>Now we can compare the results with original data by considering a PCA plot</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;scimpute_count.txt&quot;</span>)
<span class="kw">colnames</span>(res) &lt;-<span class="st"> </span><span class="ot">NULL</span>
res &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">logcounts =</span> <span class="kw">log2</span>(<span class="kw">as.matrix</span>(res) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)), 
    <span class="dt">colData =</span> <span class="kw">colData</span>(deng)
)
<span class="kw">rowData</span>(res)<span class="op">$</span>feature_symbol &lt;-<span class="st"> </span><span class="kw">rowData</span>(deng)<span class="op">$</span>feature_symbol
<span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="28-imputation_files/figure-html/unnamed-chunk-4-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Compare this result to the original data in Chapter <a href="biological-analysis.html#clust-methods">8.2</a>. What are the most significant differences?</p>
<p>To evaluate the impact of the imputation, we use <code>SC3</code> to cluster the imputed matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(res)
<span class="kw">metadata</span>(res)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3</span>(res, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">gene_filter =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">adjustedRandIndex</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2, <span class="kw">colData</span>(res)<span class="op">$</span>sc3_10_clusters)</code></pre></div>
<pre><code>## [1] 0.4687332</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>
)</code></pre></div>
<p><img src="28-imputation_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise:</strong> Based on the PCA and the clustering results, do you think that imputation using <code>scImpute</code> is a good idea for the Deng dataset?</p>
</div>
<div id="magic" class="section level3">
<h3><span class="header-section-number">8.5.2</span> MAGIC</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system</span>(<span class="st">&quot;python3 utils/MAGIC.py -d deng.csv -o MAGIC_count.csv --cell-axis columns -l 1 --pca-non-random csv&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;MAGIC_count.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)
<span class="kw">rownames</span>(res) &lt;-<span class="st"> </span>res[,<span class="dv">1</span>]
res &lt;-<span class="st"> </span>res[,<span class="op">-</span><span class="dv">1</span>]
res &lt;-<span class="st"> </span><span class="kw">t</span>(res)
res &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">logcounts =</span> res), 
    <span class="dt">colData =</span> <span class="kw">colData</span>(deng)
)
<span class="kw">rowData</span>(res)<span class="op">$</span>feature_symbol &lt;-<span class="st"> </span><span class="kw">rownames</span>(res)
<span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="28-imputation_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Compare this result to the original data in Chapter <a href="biological-analysis.html#clust-methods">8.2</a>. What are the most significant differences?</p>
<p>To evaluate the impact of the imputation, we use <code>SC3</code> to cluster the imputed matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(res)
<span class="kw">metadata</span>(res)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3</span>(res, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">gene_filter =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">adjustedRandIndex</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2, <span class="kw">colData</span>(res)<span class="op">$</span>sc3_10_clusters)</code></pre></div>
<pre><code>## [1] 0.3752866</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>
)</code></pre></div>
<p><img src="28-imputation_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /> <strong>Exercise:</strong> What is the difference between <code>scImpute</code> and <code>MAGIC</code> based on the PCA and clustering analysis? Which one do you think is best to use?</p>
</div>
<div id="sessioninfo-8" class="section level3">
<h3><span class="header-section-number">8.5.3</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    methods   parallel  stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] mclust_5.4                 scater_1.6.3              
##  [3] SingleCellExperiment_1.0.0 SummarizedExperiment_1.8.1
##  [5] DelayedArray_0.4.1         matrixStats_0.53.1        
##  [7] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
##  [9] IRanges_2.12.0             S4Vectors_0.16.0          
## [11] ggplot2_2.2.1              Biobase_2.38.0            
## [13] BiocGenerics_0.24.0        SC3_1.7.7                 
## [15] scImpute_0.0.5             doParallel_1.0.11         
## [17] iterators_1.0.9            foreach_1.4.4             
## [19] penalized_0.9-50           survival_2.40-1           
## [21] kernlab_0.9-25             knitr_1.20                
## 
## loaded via a namespace (and not attached):
##  [1] ggbeeswarm_0.6.0       colorspace_1.3-2       rjson_0.2.15          
##  [4] class_7.3-14           rprojroot_1.3-2        XVector_0.18.0        
##  [7] bit64_0.9-7            AnnotationDbi_1.40.0   mvtnorm_1.0-7         
## [10] codetools_0.2-15       splines_3.4.3          tximport_1.6.0        
## [13] robustbase_0.92-8      cluster_2.0.6          pheatmap_1.0.8        
## [16] shinydashboard_0.6.1   shiny_1.0.5            rrcov_1.4-3           
## [19] compiler_3.4.3         httr_1.3.1             backports_1.1.2       
## [22] assertthat_0.2.0       Matrix_1.2-7.1         lazyeval_0.2.1        
## [25] limma_3.34.9           htmltools_0.3.6        prettyunits_1.0.2     
## [28] tools_3.4.3            bindrcpp_0.2           gtable_0.2.0          
## [31] glue_1.2.0             GenomeInfoDbData_1.0.0 reshape2_1.4.3        
## [34] dplyr_0.7.4            doRNG_1.6.6            Rcpp_0.12.15          
## [37] gdata_2.18.0           xfun_0.1               stringr_1.3.0         
## [40] mime_0.5               rngtools_1.2.4         gtools_3.5.0          
## [43] WriteXLS_4.0.0         XML_3.98-1.10          edgeR_3.20.9          
## [46] DEoptimR_1.0-8         zlibbioc_1.24.0        scales_0.5.0          
## [49] rhdf5_2.22.0           RColorBrewer_1.1-2     yaml_2.1.17           
## [52] memoise_1.1.0          gridExtra_2.3          pkgmaker_0.22         
## [55] biomaRt_2.34.2         stringi_1.1.6          RSQLite_2.0           
## [58] pcaPP_1.9-73           e1071_1.6-8            caTools_1.17.1        
## [61] rlang_0.2.0            pkgconfig_2.0.1        bitops_1.0-6          
## [64] evaluate_0.10.1        lattice_0.20-34        ROCR_1.0-7            
## [67] bindr_0.1              labeling_0.3           cowplot_0.9.2         
## [70] bit_1.1-12             plyr_1.8.4             magrittr_1.5          
## [73] bookdown_0.7           R6_2.2.2               gplots_3.0.1          
## [76] DBI_0.7                pillar_1.2.1           RCurl_1.95-4.10       
## [79] tibble_1.4.2           KernSmooth_2.23-15     rmarkdown_1.8         
## [82] viridis_0.5.0          progress_1.1.2         locfit_1.5-9.1        
## [85] grid_3.4.3             data.table_1.10.4-3    blob_1.1.0            
## [88] digest_0.6.15          xtable_1.8-2           httpuv_1.3.6.1        
## [91] munsell_0.4.3          registry_0.5           beeswarm_0.2.3        
## [94] viridisLite_0.3.0      vipor_0.4.5</code></pre>

</div>
</div>
<div id="dechapter" class="section level2">
<h2><span class="header-section-number">8.6</span> Differential Expression (DE) analysis</h2>
<div id="bulk-rna-seq-1" class="section level3">
<h3><span class="header-section-number">8.6.1</span> Bulk RNA-seq</h3>
<p>One of the most common types of analyses when working with bulk RNA-seq data is to identify differentially expressed genes. By comparing the genes that change between two conditions, e.g. mutant and wild-type or stimulated and unstimulated, it is possible to characterize the molecular mechanisms underlying the change.</p>
<p>Several different methods, e.g. <a href="https://bioconductor.org/packages/DESeq2">DESeq2</a> and <a href="https://bioconductor.org/packages/release/bioc/html/edgeR.html">edgeR</a>, have been developed for bulk RNA-seq. Moreover, there are also extensive <a href="http://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-9-r95">datasets</a> available where the RNA-seq data has been validated using RT-qPCR. These data can be used to benchmark DE finding algorithms and the available evidence suggests that the algorithms are performing quite well.</p>
</div>
<div id="single-cell-rna-seq" class="section level3">
<h3><span class="header-section-number">8.6.2</span> Single cell RNA-seq</h3>
<p>In contrast to bulk RNA-seq, in scRNA-seq we usually do not have a defined set of experimental conditions. Instead, as was shown in a previous chapter (<a href="biological-analysis.html#clust-methods">8.2</a>) we can identify the cell groups by using an unsupervised clustering approach. Once the groups have been identified one can find differentially expressed genes either by comparing the differences in variance between the groups (like the Kruskal-Wallis test implemented in SC3), or by comparing gene expression between clusters in a pairwise manner. In the following chapter we will mainly consider tools developed for pairwise comparisons.</p>
</div>
<div id="differences-in-distribution" class="section level3">
<h3><span class="header-section-number">8.6.3</span> Differences in Distribution</h3>
<p>Unlike bulk RNA-seq, we generally have a large number of samples (i.e. cells) for each group we are comparing in single-cell experiments. Thus we can take advantage of the whole distribution of expression values in each group to identify differences between groups rather than only comparing estimates of mean-expression as is standard for bulk RNASeq.</p>
<p>There are two main approaches to comparing distributions. Firstly, we can use existing statistical models/distributions and fit the same type of model to the expression in each group then test for differences in the parameters for each model, or test whether the model fits better if a particular paramter is allowed to be different according to group. For instance in Chapter <a href="cleaning-the-expression-matrix.html#dealing-with-confounders">7.10</a> we used edgeR to test whether allowing mean expression to be different in different batches significantly improved the fit of a negative binomial model of the data.</p>
<p>Alternatively, we can use a non-parametric test which does not assume that expression values follow any particular distribution, e.g. the <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test (KS-test)</a>. Non-parametric tests generally convert observed expression values to ranks and test whether the distribution of ranks for one group are signficantly different from the distribution of ranks for the other group. However, some non-parametric methods fail in the presence of a large number of tied values, such as the case for dropouts (zeros) in single-cell RNA-seq expression data. Moreover, if the conditions for a parametric test hold, then it will typically be more powerful than a non-parametric test.</p>
</div>
<div id="models-of-single-cell-rnaseq-data" class="section level3">
<h3><span class="header-section-number">8.6.4</span> Models of single-cell RNASeq data</h3>
<p>The most common model of RNASeq data is the negative binomial model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">hist</span>(
    <span class="kw">rnbinom</span>(
        <span class="dv">1000</span>, 
        <span class="dt">mu =</span> <span class="dv">10</span>, 
        <span class="dt">size =</span> <span class="dv">100</span>), 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Negative Binomial&quot;</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:nb-plot"></span>
<img src="29-de-intro_files/figure-html/nb-plot-1.png" alt="Negative Binomial distribution of read counts for a single gene across 1000 cells" width="672" />
<p class="caption">
Figure 8.12: Negative Binomial distribution of read counts for a single gene across 1000 cells
</p>
</div>
<p>Mean: <span class="math inline">\(\mu = mu\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = mu + mu^2/size\)</span></p>
<p>It is parameterized by the mean expression (mu) and the dispersion (size), which is inversely related to the variance. The negative binomial model fits bulk RNA-seq data very well and it is used for most statistical methods designed for such data. In addition, it has been show to fit the distribution of molecule counts obtained from data tagged by unique molecular identifiers (UMIs) quite well (<a href="http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html">Grun et al. 2014</a>, <a href="http://genome.cshlp.org/content/21/7/1160">Islam et al. 2011</a>).</p>
<p>However, a raw negative binomial model does not fit full-length transcript data as well due to the high dropout rates relative to the non-zero read counts. For this type of data a variety of zero-inflated negative binomial models have been proposed (e.g. <a href="https://bioconductor.org/packages/release/bioc/html/MAST.html">MAST</a>, <a href="https://bioconductor.org/packages/release/bioc/html/scde.html">SCDE</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d &lt;-<span class="st"> </span><span class="fl">0.5</span>;
counts &lt;-<span class="st"> </span><span class="kw">rnbinom</span>(
    <span class="dv">1000</span>, 
    <span class="dt">mu =</span> <span class="dv">10</span>, 
    <span class="dt">size =</span> <span class="dv">100</span>
)
counts[<span class="kw">runif</span>(<span class="dv">1000</span>) <span class="op">&lt;</span><span class="st"> </span>d] &lt;-<span class="st"> </span><span class="dv">0</span>
<span class="kw">hist</span>(
    counts, 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Zero-inflated NB&quot;</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:zero-inflation-plot"></span>
<img src="29-de-intro_files/figure-html/zero-inflation-plot-1.png" alt="Zero-inflated Negative Binomial distribution" width="672" />
<p class="caption">
Figure 8.13: Zero-inflated Negative Binomial distribution
</p>
</div>
<p>Mean: <span class="math inline">\(\mu = mu \cdot (1 - d)\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = \mu \cdot (1-d) \cdot (1 + d \cdot \mu + \mu / size)\)</span></p>
<p>These models introduce a new parameter <span class="math inline">\(d\)</span>, for the dropout rate, to the negative binomial model. As we saw in Chapter 19, the dropout rate of a gene is strongly correlated with the mean expression of the gene. Different zero-inflated negative binomial models use different relationships between mu and d and some may fit <span class="math inline">\(\mu\)</span> and <span class="math inline">\(d\)</span> to the expression of each gene independently.</p>
<p>Finally, several methods use a Poisson-Beta distribution which is based on a mechanistic model of transcriptional bursting. There is strong experimental support for this model (<a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-1-r7">Kim and Marioni, 2013</a>) and it provides a good fit to scRNA-seq data but it is less easy to use than the negative-binomial models and much less existing methods upon which to build than the negative binomial model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="fl">0.1</span>
b &lt;-<span class="st"> </span><span class="fl">0.1</span>
g &lt;-<span class="st"> </span><span class="dv">100</span>
lambdas &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1000</span>, a, b)
counts &lt;-<span class="st"> </span><span class="kw">sapply</span>(g<span class="op">*</span>lambdas, <span class="cf">function</span>(l) {<span class="kw">rpois</span>(<span class="dv">1</span>, <span class="dt">lambda =</span> l)})
<span class="kw">hist</span>(
    counts, 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Poisson-Beta&quot;</span>
)</code></pre></div>
<p><img src="29-de-intro_files/figure-html/pois-beta-plot-1.png" width="672" style="display: block; margin: auto;" /> Mean: <span class="math inline">\(\mu = g \cdot a / (a + b)\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = g^2 \cdot a \cdot b/((a + b + 1) \cdot (a + b)^2)\)</span></p>
<p>This model uses three parameters: <span class="math inline">\(a\)</span> the rate of activation of transcription; <span class="math inline">\(b\)</span> the rate of inhibition of transcription; and <span class="math inline">\(g\)</span> the rate of transcript production while transcription is active at the locus. Differential expression methods may test each of the parameters for differences across groups or only one (often <span class="math inline">\(g\)</span>).</p>
<p>All of these models may be further expanded to explicitly account for other sources of gene expression differences such as batch-effect or library depth depending on the particular DE algorithm.</p>
<p><strong>Exercise</strong>: Vary the parameters of each distribution to explore how they affect the distribution of gene expression. How similar are the Poisson-Beta and Negative Binomial models?</p>

</div>
</div>
<div id="de-in-a-real-dataset" class="section level2">
<h2><span class="header-section-number">8.7</span> DE in a real dataset</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(edgeR)
<span class="kw">library</span>(monocle)
<span class="kw">library</span>(MAST)
<span class="kw">library</span>(ROCR)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<div id="introduction-8" class="section level3">
<h3><span class="header-section-number">8.7.1</span> Introduction</h3>
<p>To test different single-cell differential expression methods we will be using the Blischak dataset from Chapters 7-17. For this experiment bulk RNA-seq data for each cell-line was generated in addition to single-cell data. We will use the differentially expressed genes identified using standard methods on the respective bulk data as the ground truth for evaluating the accuracy of each single-cell method. To save time we have pre-computed these for you. You can run the commands below to load these data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DE &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/TPs.txt&quot;</span>)
notDE &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/TNs.txt&quot;</span>)
GroundTruth &lt;-<span class="st"> </span><span class="kw">list</span>(
    <span class="dt">DE =</span> <span class="kw">as.character</span>(<span class="kw">unlist</span>(DE)), 
    <span class="dt">notDE =</span> <span class="kw">as.character</span>(<span class="kw">unlist</span>(notDE))
)</code></pre></div>
<p>This ground truth has been produce for the comparison of individual NA19101 to NA19239. Now load the respective single-cell data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">molecules &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/molecules.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>)
anno &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/annotation.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)
keep &lt;-<span class="st"> </span>anno[,<span class="dv">1</span>] <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span> <span class="op">|</span><span class="st"> </span>anno[,<span class="dv">1</span>] <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>
data &lt;-<span class="st"> </span>molecules[,keep]
group &lt;-<span class="st"> </span>anno[keep,<span class="dv">1</span>]
batch &lt;-<span class="st"> </span>anno[keep,<span class="dv">4</span>]
<span class="co"># remove genes that aren&#39;t expressed in at least 6 cells</span>
gkeep &lt;-<span class="st"> </span><span class="kw">rowSums</span>(data <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>;
counts &lt;-<span class="st"> </span>data[gkeep,]
<span class="co"># Library size normalization</span>
lib_size =<span class="st"> </span><span class="kw">colSums</span>(counts)
norm &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">t</span>(counts)<span class="op">/</span>lib_size <span class="op">*</span><span class="st"> </span><span class="kw">median</span>(lib_size)) 
<span class="co"># Variant of CPM for datasets with library sizes of fewer than 1 mil molecules</span></code></pre></div>
<p>Now we will compare various single-cell DE methods. Note that we will only be running methods which are available as R-packages and run relatively quickly.</p>
</div>
<div id="kolmogorov-smirnov-test" class="section level3">
<h3><span class="header-section-number">8.7.2</span> Kolmogorov-Smirnov test</h3>
<p>The types of test that are easiest to work with are non-parametric ones. The most commonly used non-parametric test is the <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test</a> (KS-test) and we can use it to compare the distributions for each gene in the two individuals.</p>
<p>The KS-test quantifies the distance between the empirical cummulative distributions of the expression of each gene in each of the two populations. It is sensitive to changes in mean experession and changes in variability. However it assumes data is continuous and may perform poorly when data contains a large number of identical values (eg. zeros). Another issue with the KS-test is that it can be very sensitive for large sample sizes and thus it may end up as significant even though the magnitude of the difference is very small.</p>
<div class="figure" style="text-align: center"><span id="fig:ks-statistic"></span>
<img src="figures/KS2_Example.png" alt="Illustration of the two-sample Kolmogorov–Smirnov statistic. Red and blue lines each correspond to an empirical distribution function, and the black arrow is the two-sample KS statistic. (taken from [here](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test))" width="60%" />
<p class="caption">
Figure 8.14: Illustration of the two-sample Kolmogorov–Smirnov statistic. Red and blue lines each correspond to an empirical distribution function, and the black arrow is the two-sample KS statistic. (taken from <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">here</a>)
</p>
</div>
<p>Now run the test:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pVals &lt;-<span class="st"> </span><span class="kw">apply</span>(
    norm, <span class="dv">1</span>, <span class="cf">function</span>(x) {
        <span class="kw">ks.test</span>(
            x[group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>], 
            x[group <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>]
        )<span class="op">$</span>p.value
    }
)
<span class="co"># multiple testing correction</span>
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)</code></pre></div>
<p>This code “applies” the function to each row (specified by 1) of the expression matrix, data. In the function we are returning just the p.value from the ks.test output. We can now consider how many of the ground truth positive and negative DE genes are detected by the KS-test:</p>
<div id="evaluating-accuracy" class="section level4">
<h4><span class="header-section-number">8.7.2.1</span> Evaluating Accuracy</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sigDE &lt;-<span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>]
<span class="kw">length</span>(sigDE) </code></pre></div>
<pre><code>## [1] 5095</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes</span>
<span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span>sigDE) </code></pre></div>
<pre><code>## [1] 792</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes that are true DE genes</span>
<span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span>sigDE)</code></pre></div>
<pre><code>## [1] 3190</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes that are truly not-DE</span></code></pre></div>
<p>As you can see many more of our ground truth negative genes were identified as DE by the KS-test (false positives) than ground truth positive genes (true positives), however this may be due to the larger number of notDE genes thus we typically normalize these counts as the True positive rate (TPR), TP/(TP + FN), and False positive rate (FPR), FP/(FP+TP).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tp &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span>sigDE)
fp &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span>sigDE)
tn &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.05</span>])
fn &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.05</span>])
tpr &lt;-<span class="st"> </span>tp<span class="op">/</span>(tp <span class="op">+</span><span class="st"> </span>fn)
fpr &lt;-<span class="st"> </span>fp<span class="op">/</span>(fp <span class="op">+</span><span class="st"> </span>tn)
<span class="kw">cat</span>(<span class="kw">c</span>(tpr, fpr))</code></pre></div>
<pre><code>## 0.7346939 0.2944706</code></pre>
<p>Now we can see the TPR is much higher than the FPR indicating the KS test is identifying DE genes.</p>
<p>So far we’ve only evaluated the performance at a single significance threshold. Often it is informative to vary the threshold and evaluate performance across a range of values. This is then plotted as a receiver-operating-characteristic curve (ROC) and a general accuracy statistic can be calculated as the area under this curve (AUC). We will use the ROCR package to facilitate this plotting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Only consider genes for which we know the ground truth</span>
pVals &lt;-<span class="st"> </span>pVals[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE <span class="op">|</span><span class="st"> </span>
<span class="st">               </span><span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>notDE] 
truth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="dt">times =</span> <span class="kw">length</span>(pVals));
truth[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE] =<span class="st"> </span><span class="dv">0</span>;
pred &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">prediction</span>(pVals, truth)
perf &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;tpr&quot;</span>, <span class="st">&quot;fpr&quot;</span>)
ROCR<span class="op">::</span><span class="kw">plot</span>(perf)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:ks-roc-plot"></span>
<img src="30-de-real_files/figure-html/ks-roc-plot-1.png" alt="ROC curve for KS-test." width="672" />
<p class="caption">
Figure 8.15: ROC curve for KS-test.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aucObj &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;auc&quot;</span>)
aucObj<span class="op">@</span>y.values[[<span class="dv">1</span>]] <span class="co"># AUC</span></code></pre></div>
<pre><code>## [1] 0.7954796</code></pre>
<p>Finally to facilitate the comparisons of other DE methods let’s put this code into a function so we don’t need to repeat it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DE_Quality_AUC &lt;-<span class="st"> </span><span class="cf">function</span>(pVals) {
    pVals &lt;-<span class="st"> </span>pVals[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE <span class="op">|</span><span class="st"> </span>
<span class="st">                   </span><span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>notDE]
    truth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="dt">times =</span> <span class="kw">length</span>(pVals));
    truth[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE] =<span class="st"> </span><span class="dv">0</span>;
    pred &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">prediction</span>(pVals, truth)
    perf &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;tpr&quot;</span>, <span class="st">&quot;fpr&quot;</span>)
    ROCR<span class="op">::</span><span class="kw">plot</span>(perf)
    aucObj &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;auc&quot;</span>)
    <span class="kw">return</span>(aucObj<span class="op">@</span>y.values[[<span class="dv">1</span>]])
}</code></pre></div>
</div>
</div>
<div id="wilcoxmann-whitney-u-test" class="section level3">
<h3><span class="header-section-number">8.7.3</span> Wilcox/Mann-Whitney-U Test</h3>
<p>The Wilcox-rank-sum test is another non-parametric test, but tests specifically if values in one group are greater/less than the values in the other group. Thus it is often considered a test for difference in median expression between two groups; whereas the KS-test is sensitive to any change in distribution of expression values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pVals &lt;-<span class="st"> </span><span class="kw">apply</span>(
    norm, <span class="dv">1</span>, <span class="cf">function</span>(x) {
        <span class="kw">wilcox.test</span>(
            x[group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>], 
            x[group <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>]
        )<span class="op">$</span>p.value
    }
)
<span class="co"># multiple testing correction</span>
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:wilcox-plot"></span>
<img src="30-de-real_files/figure-html/wilcox-plot-1.png" alt="ROC curve for Wilcox test." width="672" />
<p class="caption">
Figure 8.16: ROC curve for Wilcox test.
</p>
</div>
<pre><code>## [1] 0.8320326</code></pre>
</div>
<div id="edger" class="section level3">
<h3><span class="header-section-number">8.7.4</span> edgeR</h3>
<p>We’ve already used edgeR for differential expression in Chapter <a href="cleaning-the-expression-matrix.html#dealing-with-confounders">7.10</a>. edgeR is based on a negative binomial model of gene expression and uses a generalized linear model (GLM) framework, the enables us to include other factors such as batch to the model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dge &lt;-<span class="st"> </span><span class="kw">DGEList</span>(
    <span class="dt">counts =</span> counts, 
    <span class="dt">norm.factors =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">length</span>(counts[<span class="dv">1</span>,])), 
    <span class="dt">group =</span> group
)
group_edgeR &lt;-<span class="st"> </span><span class="kw">factor</span>(group)
design &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>group_edgeR)
dge &lt;-<span class="st"> </span><span class="kw">estimateDisp</span>(dge, <span class="dt">design =</span> design, <span class="dt">trend.method =</span> <span class="st">&quot;none&quot;</span>)
fit &lt;-<span class="st"> </span><span class="kw">glmFit</span>(dge, design)
res &lt;-<span class="st"> </span><span class="kw">glmLRT</span>(fit)
pVals &lt;-<span class="st"> </span>res<span class="op">$</span>table[,<span class="dv">4</span>]
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">rownames</span>(res<span class="op">$</span>table)

pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:edger-plot"></span>
<img src="30-de-real_files/figure-html/edger-plot-1.png" alt="ROC curve for edgeR." width="672" />
<p class="caption">
Figure 8.17: ROC curve for edgeR.
</p>
</div>
<pre><code>## [1] 0.8466764</code></pre>
</div>
<div id="monocle-1" class="section level3">
<h3><span class="header-section-number">8.7.5</span> Monocle</h3>
<p><a href="https://bioconductor.org/packages/release/bioc/html/monocle.html">Monocle</a> can use several different models for DE. For count data it recommends the Negative Binomial model (negbinomial.size). For normalized data it recommends log-transforming it then using a normal distribution (gaussianff). Similar to edgeR this method uses a GLM framework so in theory can account for batches, however in practice the model fails for this dataset if batches are included.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">group =</span> group, <span class="dt">batch =</span> batch)
<span class="kw">rownames</span>(pd) &lt;-<span class="st"> </span><span class="kw">colnames</span>(counts)
pd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data =</span> pd)

Obj &lt;-<span class="st"> </span><span class="kw">newCellDataSet</span>(
    <span class="kw">as.matrix</span>(counts), 
    <span class="dt">phenoData =</span> pd, 
    <span class="dt">expressionFamily =</span> <span class="kw">negbinomial.size</span>()
)
Obj &lt;-<span class="st"> </span><span class="kw">estimateSizeFactors</span>(Obj)
Obj &lt;-<span class="st"> </span><span class="kw">estimateDispersions</span>(Obj)
res &lt;-<span class="st"> </span><span class="kw">differentialGeneTest</span>(Obj, <span class="dt">fullModelFormulaStr =</span> <span class="st">&quot;~group&quot;</span>)

pVals &lt;-<span class="st"> </span>res[,<span class="dv">3</span>]
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">rownames</span>(res)
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:Monocle-plot"></span>
<img src="30-de-real_files/figure-html/Monocle-plot-1.png" alt="ROC curve for Monocle." width="672" />
<p class="caption">
Figure 8.18: ROC curve for Monocle.
</p>
</div>
<pre><code>## [1] 0.8252662</code></pre>
<p><strong>Exercise</strong>: Compare the results using the negative binomial model on counts and those from using the normal/gaussian model (<code>gaussianff()</code>) on log-transformed normalized counts.</p>
<strong>Answer</strong>:
<div class="figure" style="text-align: center"><span id="fig:Monocle-plot2"></span>
<img src="30-de-real_files/figure-html/Monocle-plot2-1.png" alt="ROC curve for Monocle-gaussian." width="672" />
<p class="caption">
Figure 8.19: ROC curve for Monocle-gaussian.
</p>
</div>
<pre><code>## [1] 0.7357829</code></pre>
</div>
<div id="mast" class="section level3">
<h3><span class="header-section-number">8.7.6</span> MAST</h3>
<p><a href="https://bioconductor.org/packages/release/bioc/html/MAST.html">MAST</a> is based on a zero-inflated negative binomial model. It tests for differential expression using a hurdle model to combine tests of discrete (0 vs not zero) and continuous (non-zero values) aspects of gene expression. Again this uses a linear modelling framework to enable complex models to be considered.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">log_counts &lt;-<span class="st"> </span><span class="kw">log</span>(counts <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span>)
fData &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">names =</span> <span class="kw">rownames</span>(log_counts))
<span class="kw">rownames</span>(fData) &lt;-<span class="st"> </span><span class="kw">rownames</span>(log_counts);
cData &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">cond =</span> group)
<span class="kw">rownames</span>(cData) &lt;-<span class="st"> </span><span class="kw">colnames</span>(log_counts)

obj &lt;-<span class="st"> </span><span class="kw">FromMatrix</span>(<span class="kw">as.matrix</span>(log_counts), cData, fData)
<span class="kw">colData</span>(obj)<span class="op">$</span>cngeneson &lt;-<span class="st"> </span><span class="kw">scale</span>(<span class="kw">colSums</span>(<span class="kw">assay</span>(obj) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>))
cond &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">colData</span>(obj)<span class="op">$</span>cond)

<span class="co"># Model expression as function of condition &amp; number of detected genes</span>
zlmCond &lt;-<span class="st"> </span><span class="kw">zlm.SingleCellAssay</span>(<span class="op">~</span><span class="st"> </span>cond <span class="op">+</span><span class="st"> </span>cngeneson, obj) </code></pre></div>
<pre><code>## Warning: &#39;zlm.SingleCellAssay&#39; is deprecated.
## Use &#39;zlm&#39; instead.
## See help(&quot;Deprecated&quot;)</code></pre>
<pre><code>## Warning in .nextMethod(object = object, value = value): Coefficients
## condNA19239 are never estimible and will be dropped.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">summaryCond &lt;-<span class="st"> </span><span class="kw">summary</span>(zlmCond, <span class="dt">doLRT =</span> <span class="st">&quot;condNA19101&quot;</span>)
summaryDt &lt;-<span class="st"> </span>summaryCond<span class="op">$</span>datatable

summaryDt &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(summaryDt)
pVals &lt;-<span class="st"> </span><span class="kw">unlist</span>(summaryDt[summaryDt<span class="op">$</span>component <span class="op">==</span><span class="st"> &quot;H&quot;</span>,<span class="dv">4</span>]) <span class="co"># H = hurdle model</span>
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">unlist</span>(summaryDt[summaryDt<span class="op">$</span>component <span class="op">==</span><span class="st"> &quot;H&quot;</span>,<span class="dv">1</span>])
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:MAST-plot"></span>
<img src="30-de-real_files/figure-html/MAST-plot-1.png" alt="ROC curve for MAST." width="672" />
<p class="caption">
Figure 8.20: ROC curve for MAST.
</p>
</div>
<pre><code>## [1] 0.8284046</code></pre>
</div>
<div id="slow-methods-1h-to-run" class="section level3">
<h3><span class="header-section-number">8.7.7</span> Slow Methods (&gt;1h to run)</h3>
<p>These methods are too slow to run today but we encourage you to try them out on your own:</p>
</div>
<div id="bpsc" class="section level3">
<h3><span class="header-section-number">8.7.8</span> BPSC</h3>
<p><a href="https://academic.oup.com/bioinformatics/article/32/14/2128/2288270/Beta-Poisson-model-for-single-cell-RNA-seq-data">BPSC</a> uses the Poisson-Beta model of single-cell gene expression, which we discussed in the previous chapter, and combines it with generalized linear models which we’ve already encountered when using edgeR. BPSC performs comparisons of one or more groups to a reference group (“control”) and can include other factors such as batches in the model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(BPSC)
bpsc_data &lt;-<span class="st"> </span>norm[,batch<span class="op">==</span><span class="st">&quot;NA19101.r1&quot;</span> <span class="op">|</span><span class="st"> </span>batch<span class="op">==</span><span class="st">&quot;NA19239.r1&quot;</span>]
bpsc_group =<span class="st"> </span>group[batch<span class="op">==</span><span class="st">&quot;NA19101.r1&quot;</span> <span class="op">|</span><span class="st"> </span>batch<span class="op">==</span><span class="st">&quot;NA19239.r1&quot;</span>]

control_cells &lt;-<span class="st"> </span><span class="kw">which</span>(bpsc_group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>)
design &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>bpsc_group)
coef=<span class="dv">2</span> <span class="co"># group label</span>
res=<span class="kw">BPglm</span>(<span class="dt">data=</span>bpsc_data, <span class="dt">controlIds=</span>control_cells, <span class="dt">design=</span>design, <span class="dt">coef=</span>coef, 
                <span class="dt">estIntPar=</span><span class="ot">FALSE</span>, <span class="dt">useParallel =</span> <span class="ot">FALSE</span>)
pVals =<span class="st"> </span>res<span class="op">$</span>PVAL
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
</div>
<div id="scde" class="section level3">
<h3><span class="header-section-number">8.7.9</span> SCDE</h3>
<p><a href="http://hms-dbmi.github.io/scde/">SCDE</a> is the first single-cell specific DE method. It fits a zero-inflated negative binomial model to expression data using Bayesian statistics. The usage below tests for differences in mean expression of individual genes across groups but recent versions include methods to test for differences in mean expression or dispersion of groups of genes, usually representing a pathway.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scde)
cnts &lt;-<span class="st"> </span><span class="kw">apply</span>(
    counts,
    <span class="dv">2</span>,
    <span class="cf">function</span>(x) {
        <span class="kw">storage.mode</span>(x) &lt;-<span class="st"> &#39;integer&#39;</span>
        <span class="kw">return</span>(x)
    }
)
<span class="kw">names</span>(group) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(group)
<span class="kw">colnames</span>(cnts) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(group)
o.ifm &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.error.models</span>(
    <span class="dt">counts =</span> cnts,
    <span class="dt">groups =</span> group,
    <span class="dt">n.cores =</span> <span class="dv">1</span>,
    <span class="dt">threshold.segmentation =</span> <span class="ot">TRUE</span>,
    <span class="dt">save.crossfit.plots =</span> <span class="ot">FALSE</span>,
    <span class="dt">save.model.plots =</span> <span class="ot">FALSE</span>,
    <span class="dt">verbose =</span> <span class="dv">0</span>,
    <span class="dt">min.size.entries =</span> <span class="dv">2</span>
)
priors &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.expression.prior</span>(
    <span class="dt">models =</span> o.ifm,
    <span class="dt">counts =</span> cnts,
    <span class="dt">length.out =</span> <span class="dv">400</span>,
    <span class="dt">show.plot =</span> <span class="ot">FALSE</span>
)
resSCDE &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.expression.difference</span>(
    o.ifm,
    cnts,
    priors,
    <span class="dt">groups =</span> group,
    <span class="dt">n.randomizations =</span> <span class="dv">100</span>,
    <span class="dt">n.cores =</span> <span class="dv">1</span>,
    <span class="dt">verbose =</span> <span class="dv">0</span>
)
<span class="co"># Convert Z-scores into 2-tailed p-values</span>
pVals &lt;-<span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(resSCDE<span class="op">$</span>cZ), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>) <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
</div>
<div id="sessioninfo-9" class="section level3">
<h3><span class="header-section-number">8.7.10</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
##  [1] splines   stats4    parallel  methods   stats     graphics  grDevices
##  [8] utils     datasets  base     
## 
## other attached packages:
##  [1] ROCR_1.0-7                 gplots_3.0.1              
##  [3] MAST_1.4.1                 SummarizedExperiment_1.8.1
##  [5] DelayedArray_0.4.1         matrixStats_0.53.1        
##  [7] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
##  [9] IRanges_2.12.0             S4Vectors_0.16.0          
## [11] monocle_2.6.3              DDRTree_0.1.5             
## [13] irlba_2.3.2                VGAM_1.0-5                
## [15] ggplot2_2.2.1              Biobase_2.38.0            
## [17] BiocGenerics_0.24.0        Matrix_1.2-7.1            
## [19] edgeR_3.20.9               limma_3.34.9              
## [21] scRNA.seq.funcs_0.1.0      knitr_1.20                
## 
## loaded via a namespace (and not attached):
##  [1] bitops_1.0-6           RColorBrewer_1.1-2     rprojroot_1.3-2       
##  [4] tools_3.4.3            backports_1.1.2        R6_2.2.2              
##  [7] KernSmooth_2.23-15     hypergeo_1.2-13        lazyeval_0.2.1        
## [10] colorspace_1.3-2       gridExtra_2.3          moments_0.14          
## [13] compiler_3.4.3         orthopolynom_1.0-5     bookdown_0.7          
## [16] slam_0.1-42            caTools_1.17.1         scales_0.5.0          
## [19] stringr_1.3.0          digest_0.6.15          rmarkdown_1.8         
## [22] XVector_0.18.0         pkgconfig_2.0.1        htmltools_0.3.6       
## [25] highr_0.6              rlang_0.2.0            FNN_1.1               
## [28] bindr_0.1              combinat_0.0-8         gtools_3.5.0          
## [31] dplyr_0.7.4            RCurl_1.95-4.10        magrittr_1.5          
## [34] GenomeInfoDbData_1.0.0 Rcpp_0.12.15           munsell_0.4.3         
## [37] abind_1.4-5            viridis_0.5.0          stringi_1.1.6         
## [40] yaml_2.1.17            MASS_7.3-45            zlibbioc_1.24.0       
## [43] Rtsne_0.13             plyr_1.8.4             grid_3.4.3            
## [46] gdata_2.18.0           ggrepel_0.7.0          contfrac_1.1-11       
## [49] lattice_0.20-34        locfit_1.5-9.1         pillar_1.2.1          
## [52] igraph_1.1.2           reshape2_1.4.3         glue_1.2.0            
## [55] evaluate_0.10.1        data.table_1.10.4-3    deSolve_1.20          
## [58] gtable_0.2.0           RANN_2.5.1             assertthat_0.2.0      
## [61] xfun_0.1               qlcMatrix_0.9.5        HSMMSingleCell_0.112.0
## [64] viridisLite_0.3.0      tibble_1.4.2           pheatmap_1.0.8        
## [67] elliptic_1.3-7         bindrcpp_0.2           cluster_2.0.6         
## [70] fastICA_1.2-1          densityClust_0.3       statmod_1.4.30</code></pre>

</div>
</div>
<div id="comparingcombining-scrnaseq-datasets" class="section level2">
<h2><span class="header-section-number">8.8</span> Comparing/Combining scRNASeq datasets</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)</code></pre></div>
<div id="introduction-9" class="section level3">
<h3><span class="header-section-number">8.8.1</span> Introduction</h3>
<p>As more and more scRNA-seq datasets become available, carrying merged_seurat comparisons between them is key. There are two main approaches to comparing scRNASeq datasets. The first approach is “label-centric” which is focused on trying to identify equivalent cell-types/states across datasets by comparing individual cells or groups of cells. The other approach is “cross-dataset normalization” which attempts to computationally remove experiment-specific technical/biological effects so that data from multiple experiments can be combined and jointly analyzed.</p>
<p>The label-centric approach can be used with dataset with high-confidence cell-annotations, e.g. the Human Cell Atlas (HCA) <span class="citation">(Regev et al. <a href="#ref-Regev2017-mw">2017</a>)</span> or the Tabula Muris <span class="citation">(<span class="citeproc-not-found" data-reference-id="Quake2017"><strong>???</strong></span>)</span> once they are completed, to project cells or clusters from a new sample onto this reference to consider tissue composition and/or identify cells with novel/unknown identity. Conceptually, such projections are similar to the popular BLAST method <span class="citation">(Altschul et al. <a href="#ref-Altschul1990-ts">1990</a>)</span>, which makes it possible to quickly find the closest match in a database for a newly identified nucleotide or amino acid sequence. The label-centric approach can also be used to compare datasets of similar biological origin collected by different labs to ensure that the annotation and the analysis is consistent.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-3"></span>
<img src="figures/CourseCompareTypes.png" alt="Label-centric dataset comparison can be used to compare the annotations of two different samples."  />
<p class="caption">
Figure 2.4: Label-centric dataset comparison can be used to compare the annotations of two different samples.
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-4"></span>
<img src="figures/CourseAtlasAssignment.png" alt="Label-centric dataset comparison can project cells from a new experiment onto an annotated reference."  />
<p class="caption">
Figure 2.5: Label-centric dataset comparison can project cells from a new experiment onto an annotated reference.
</p>
</div>
<p>The cross-dataset normalization approach can also be used to compare datasets of similar biological origin, unlike the label-centric approach it enables the join analysis of multiple datasets to facilitate the identification of rare cell-types which may to too sparsely sampled in each individual dataset to be reliably detected. However, cross-dataset normalization is not applicable to very large and diverse references since it assumes a significant portion of the biological variablility in each of the datasets overlaps with others.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-5"></span>
<img src="figures/CourseCrossNorm.png" alt="Cross-dataset normalization enables joint-analysis of 2+ scRNASeq datasets."  />
<p class="caption">
Figure 2.6: Cross-dataset normalization enables joint-analysis of 2+ scRNASeq datasets.
</p>
</div>
</div>
<div id="datasets" class="section level3">
<h3><span class="header-section-number">8.8.2</span> Datasets</h3>
<p>We will running these methods on two human pancreas datasets: <span class="citation">(Muraro et al. <a href="#ref-Muraro2016-yk">2016</a>)</span> and <span class="citation">(Segerstolpe et al. <a href="#ref-Segerstolpe2016-wc">2016</a>)</span>. Since the pancreas has been widely studied, these datasets are well annotated.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/muraro.rds&quot;</span>)
segerstolpe &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/segerstolpe.rds&quot;</span>)</code></pre></div>
<p>This data has already been formatted for scmap. Cell type labels must be stored in the <code>cell_type1</code> column of the <code>colData</code> slots, and gene ids that are consistent across both datasets must be stored in the <code>feature_symbol</code> column of the <code>rowData</code> slots.</p>
<p>First, lets check our gene-ids match across both datasets:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol <span class="op">%in%</span><span class="st"> </span><span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol)<span class="op">/</span><span class="kw">nrow</span>(muraro)</code></pre></div>
<pre><code>## [1] 0.9599519</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol <span class="op">%in%</span><span class="st"> </span><span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol)<span class="op">/</span><span class="kw">nrow</span>(segerstolpe)</code></pre></div>
<pre><code>## [1] 0.719334</code></pre>
<p>Here we can see that 96% of the genes present in muraro match genes in segerstople and 72% of genes in segerstolpe are match genes in muraro. This is as expected because the segerstolpe dataset was more deeply sequenced than the muraro dataset. However, it highlights some of the difficulties in comparing scRNASeq datasets.</p>
<p>We can confirm this by checking the overall size of these two datasets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(muraro)</code></pre></div>
<pre><code>## [1] 19127  2126</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(segerstolpe)</code></pre></div>
<pre><code>## [1] 25525  3514</code></pre>
<p>In addition, we can check the cell-type annotations for each of these dataset using the command below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">factor</span>(<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1))</code></pre></div>
<pre><code>##      acinar       alpha        beta       delta      ductal endothelial 
##         219         812         448         193         245          21 
##     epsilon       gamma mesenchymal     unclear 
##           3         101          80           4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">factor</span>(<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1))</code></pre></div>
<pre><code>##                 acinar                  alpha                   beta 
##                    185                    886                    270 
##          co-expression                  delta                 ductal 
##                     39                    114                    386 
##            endothelial                epsilon                  gamma 
##                     16                      7                    197 
##                   mast           MHC class II         not applicable 
##                      7                      5                   1305 
##                    PSC           unclassified unclassified endocrine 
##                     54                      2                     41</code></pre>
<p>Here we can see that even though both datasets considered the same biological tissue the two datasets, they have been annotated with slightly different sets of cell-types. If you are familiar withpancreas biology you might recognize that the pancreatic stellate cells (PSCs) in segerstolpe are a type of mesenchymal stem cell which would fall under the “mesenchymal” type in muraro. However, it isn’t clear whether these two annotations should be considered synonymous or not. We can use label-centric comparison methods to determine if these two cell-type annotations are indeed equivalent.</p>
<p>Alternatively, we might be interested in understanding the function of those cells that were “unclassified endocrine” or were deemed too poor quality (“not applicable”) for the original clustering in each dataset by leveraging in formation across datasets. Either we could attempt to infer which of the existing annotations they most likely belong to using label-centric approaches or we could try to uncover a novel cell-type among them (or a sub-type within the existing annotations) using cross-dataset normalization.</p>
<p>To simplify our demonstration analyses we will remove the small classes of unassigned cells, and the poor quality cells. We will retain the “unclassified endocrine” to see if any of these methods can elucidate what cell-type they belong to.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segerstolpe &lt;-<span class="st"> </span>segerstolpe[,<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;unclassified&quot;</span>]
segerstolpe &lt;-<span class="st"> </span>segerstolpe[,<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;not applicable&quot;</span>,]
muraro &lt;-<span class="st"> </span>muraro[,<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;unclear&quot;</span>]</code></pre></div>
</div>
<div id="projecting-cells-onto-annotated-cell-types-scmap" class="section level3">
<h3><span class="header-section-number">8.8.3</span> Projecting cells onto annotated cell-types (scmap)</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scmap)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>We recently developed <code>scmap</code> <span class="citation">(Kiselev and Hemberg <a href="#ref-Kiselev2017-nb">2017</a>)</span> - a method for projecting cells from a scRNA-seq experiment onto the cell-types identified in other experiments. Additionally, a cloud version of <code>scmap</code> can be run for free, withmerged_seurat restrictions, from <a href="http://www.hemberg-lab.cloud/scmap" class="uri">http://www.hemberg-lab.cloud/scmap</a>.</p>
<div id="feature-selection-1" class="section level4">
<h4><span class="header-section-number">8.8.3.1</span> Feature Selection</h4>
<p>Once we have a <code>SingleCellExperiment</code> object we can run <code>scmap</code>. First we have to build the “index” of our reference clusters. Since we want to know whether PSCs and mesenchymal cells are synonymous we will project each dataset to the other so we will build an index for each dataset. This requires first selecting the most informative features for the reference dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">selectFeatures</span>(muraro, <span class="dt">suppress_plot =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Warning in linearModel(object, n_features): Your object does not contain
## counts() slot. Dropouts were calculated using logcounts() slot...</code></pre>
<p><img src="31-projection_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Genes highlighted with the red colour will be used in the futher analysis (projection).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segerstolpe &lt;-<span class="st"> </span><span class="kw">selectFeatures</span>(segerstolpe, <span class="dt">suppress_plot =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="31-projection_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /> From the y-axis of these plots we can see that scmap uses a dropmerged_seurat-based feature selection method.</p>
<p>Now calculate the cell-type index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">indexCluster</span>(muraro)
segerstolpe &lt;-<span class="st"> </span><span class="kw">indexCluster</span>(segerstolpe)</code></pre></div>
<p>We can also visualize the index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">heatmap</span>(<span class="kw">as.matrix</span>(<span class="kw">metadata</span>(muraro)<span class="op">$</span>scmap_cluster_index))</code></pre></div>
<p><img src="31-projection_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>You may want to adjust your features using the <code>setFeatures</code> function if features are too heavily concentrated in only a few cell-types. In this case the dropmerged_seurat-based features look good so we will just them.</p>
<p><strong>Exercise</strong> Using the rowData of each dataset how many genes were selected as features in both datasets? What does this tell you abmerged_seurat these datasets?</p>
<p><strong>Answer</strong></p>
</div>
<div id="projecting" class="section level4">
<h4><span class="header-section-number">8.8.3.2</span> Projecting</h4>
<p>scmap computes the distance from each cell to each cell-type in the reference index, then applies an empirically derived threshold to determine which cells are assigned to the closest reference cell-type and which are unassigned. To account for differences in sequencing depth distance is calculated using the spearman correlation and cosine distance and only cells with a consistent assignment with both distances are returned as assigned.</p>
<p>We will project the <code>segerstolpe</code> dataset to <code>muraro</code> dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seger_to_muraro &lt;-<span class="st"> </span><span class="kw">scmapCluster</span>(
  <span class="dt">projection =</span> segerstolpe,
  <span class="dt">index_list =</span> <span class="kw">list</span>(
    <span class="dt">muraro =</span> <span class="kw">metadata</span>(muraro)<span class="op">$</span>scmap_cluster_index
  )
)</code></pre></div>
<p>and <code>muraro</code> onto <code>segerstolpe</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro_to_seger &lt;-<span class="st"> </span><span class="kw">scmapCluster</span>(
  <span class="dt">projection =</span> muraro,
  <span class="dt">index_list =</span> <span class="kw">list</span>(
    <span class="dt">seger =</span> <span class="kw">metadata</span>(segerstolpe)<span class="op">$</span>scmap_cluster_index
  )
)</code></pre></div>
<p>Note that in each case we are projecting to a single dataset but that this could be extended to any number of datasets for which we have computed indices.</p>
<p>Now lets compare the original cell-type labels with the projected labels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1, muraro_to_seger<span class="op">$</span>scmap_cluster_labs)</code></pre></div>
<pre><code>##              
##               acinar alpha beta co-expression delta ductal endothelial
##   acinar         211     0    0             0     0      0           0
##   alpha            1   763    0            18     0      2           0
##   beta             2     1  397             7     2      2           0
##   delta            0     0    2             1   173      0           0
##   ductal           7     0    0             0     0    208           0
##   endothelial      0     0    0             0     0      0          15
##   epsilon          0     0    0             0     0      0           0
##   gamma            2     0    0             0     0      0           0
##   mesenchymal      0     0    0             0     0      1           0
##              
##               epsilon gamma MHC class II PSC unassigned
##   acinar            0     0            0   0          8
##   alpha             0     2            0   0         26
##   beta              0     5            1   2         29
##   delta             0     0            0   0         17
##   ductal            0     0            5   3         22
##   endothelial       0     0            0   1          5
##   epsilon           3     0            0   0          0
##   gamma             0    95            0   0          4
##   mesenchymal       0     0            0  77          2</code></pre>
<p>Here we can see that cell-types do map to their equivalents in segerstolpe, and importantly we see that all but one of the “mesenchymal” cells were assigned to the “PSC” class.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1, seger_to_muraro<span class="op">$</span>scmap_cluster_labs)</code></pre></div>
<pre><code>##                         
##                          acinar alpha beta delta ductal endothelial
##   acinar                    181     0    0     0      4           0
##   alpha                       0   869    1     0      0           0
##   beta                        0     0  260     0      0           0
##   co-expression               0     7   31     0      0           0
##   delta                       0     0    1   111      0           0
##   ductal                      0     0    0     0    383           0
##   endothelial                 0     0    0     0      0          14
##   epsilon                     0     0    0     0      0           0
##   gamma                       0     2    0     0      0           0
##   mast                        0     0    0     0      0           0
##   MHC class II                0     0    0     0      0           0
##   PSC                         0     0    1     0      0           0
##   unclassified endocrine      0     0    0     0      0           0
##                         
##                          epsilon gamma mesenchymal unassigned
##   acinar                       0     0           0          0
##   alpha                        0     0           0         16
##   beta                         0     0           0         10
##   co-expression                0     0           0          1
##   delta                        0     0           0          2
##   ductal                       0     0           0          3
##   endothelial                  0     0           0          2
##   epsilon                      6     0           0          1
##   gamma                        0   192           0          3
##   mast                         0     0           0          7
##   MHC class II                 0     0           0          5
##   PSC                          0     0          53          0
##   unclassified endocrine       0     0           0         41</code></pre>
<p>Again we see cell-types match each other and that all but one of the “PSCs” match the “mesenchymal” cells providing strong evidence that these two annotations should be considered synonymous.</p>
<p>We can also visualize these tables using a <a href="https://developers.google.com/chart/interactive/docs/gallery/sankey">Sankey diagram</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">getSankey</span>(<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1,  muraro_to_seger<span class="op">$</span>scmap_cluster_labs[,<span class="dv">1</span>], <span class="dt">plot_height=</span><span class="dv">400</span>))</code></pre></div>
<!-- Sankey generated in R 3.4.3 by googleVis 0.6.2 package -->
<!-- Tue May 29 15:20:30 2018 -->
<!-- jsHeader -->
<script type="text/javascript">
 
// jsData 
function gvisDataSankeyIDdd764fb78be () {
var data = new google.visualization.DataTable();
var datajson =
[
 [
"alpha ",
" alpha",
763
],
[
"beta ",
" beta",
397
],
[
"acinar ",
" acinar",
211
],
[
"ductal ",
" ductal",
208
],
[
"delta ",
" delta",
173
],
[
"gamma ",
" gamma",
95
],
[
"mesenchymal ",
" PSC",
77
],
[
"endothelial ",
" endothelial",
15
],
[
"epsilon ",
" epsilon",
3
],
[
"acinar ",
" unassigned",
8
],
[
"alpha ",
" ductal",
2
],
[
"alpha ",
" unassigned",
26
],
[
"alpha ",
" acinar",
1
],
[
"alpha ",
" co-expression",
18
],
[
"alpha ",
" gamma",
2
],
[
"beta ",
" unassigned",
29
],
[
"beta ",
" gamma",
5
],
[
"beta ",
" MHC class II",
1
],
[
"beta ",
" alpha",
1
],
[
"beta ",
" co-expression",
7
],
[
"beta ",
" acinar",
2
],
[
"beta ",
" PSC",
2
],
[
"beta ",
" ductal",
2
],
[
"beta ",
" delta",
2
],
[
"delta ",
" beta",
2
],
[
"delta ",
" unassigned",
17
],
[
"delta ",
" co-expression",
1
],
[
"ductal ",
" acinar",
7
],
[
"ductal ",
" PSC",
3
],
[
"ductal ",
" MHC class II",
5
],
[
"ductal ",
" unassigned",
22
],
[
"endothelial ",
" PSC",
1
],
[
"endothelial ",
" unassigned",
5
],
[
"gamma ",
" acinar",
2
],
[
"gamma ",
" unassigned",
4
],
[
"mesenchymal ",
" ductal",
1
],
[
"mesenchymal ",
" unassigned",
2
] 
];
data.addColumn('string','From');
data.addColumn('string','To');
data.addColumn('number','# of cells');
data.addRows(datajson);
return(data);
}
 
// jsDrawChart
function drawChartSankeyIDdd764fb78be() {
var data = gvisDataSankeyIDdd764fb78be();
var options = {};
options["width"] = 400;
options["height"] = 400;
options["sankey"] = {
                node:{
                    label:{
                        fontName:'Arial',
                        fontSize:11,color:
                        '#000000',
                        bold:true,
                        italic:false
                    },
                    colors:'#FFFFFF',
                    nodePadding:12
                },iterations:0
            };

    var chart = new google.visualization.Sankey(
    document.getElementById('SankeyIDdd764fb78be')
    );
    chart.draw(data,options);
    

}
  
 
// jsDisplayChart
(function() {
var pkgs = window.__gvisPackages = window.__gvisPackages || [];
var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
var chartid = "sankey";
  
// Manually see if chartid is in pkgs (not all browsers support Array.indexOf)
var i, newPackage = true;
for (i = 0; newPackage && i < pkgs.length; i++) {
if (pkgs[i] === chartid)
newPackage = false;
}
if (newPackage)
  pkgs.push(chartid);
  
// Add the drawChart function to the global list of callbacks
callbacks.push(drawChartSankeyIDdd764fb78be);
})();
function displayChartSankeyIDdd764fb78be() {
  var pkgs = window.__gvisPackages = window.__gvisPackages || [];
  var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
  window.clearTimeout(window.__gvisLoad);
  // The timeout is set to 100 because otherwise the container div we are
  // targeting might not be part of the document yet
  window.__gvisLoad = setTimeout(function() {
  var pkgCount = pkgs.length;
  google.load("visualization", "1", { packages:pkgs, callback: function() {
  if (pkgCount != pkgs.length) {
  // Race condition where another setTimeout call snuck in after us; if
  // that call added a package, we must not shift its callback
  return;
}
while (callbacks.length > 0)
callbacks.shift()();
} });
}, 100);
}
 
// jsFooter
</script>
<!-- jsChart -->
<script type="text/javascript" src="https://www.google.com/jsapi?callback=displayChartSankeyIDdd764fb78be"></script>
<!-- divChart -->
<div id="SankeyIDdd764fb78be" style="width: 400; height: 400;">

</div>
<p><strong>Exercise</strong> How many of the previously unclassified cells would be be able to assign to cell-types using scmap?</p>
<p><strong>Answer</strong></p>
</div>
</div>
<div id="cell-to-cell-mapping" class="section level3">
<h3><span class="header-section-number">8.8.4</span> Cell-to-Cell mapping</h3>
<p>scmap can also project each cell in one dataset to its approximate closest neighbouring cell in the reference dataset. This uses a highly optimized search algorithm allowing it to be scaled to very large references (in theory 100,000-millions of cells). However, this process is stochastic so we must fix the random seed to ensure we can reproduce our results.</p>
<p>We have already performed feature selection for this dataset so we can go straight to building the index.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">193047</span>)
segerstolpe &lt;-<span class="st"> </span><span class="kw">indexCell</span>(segerstolpe)</code></pre></div>
<pre><code>## Parameter M was not provided, will use M = n_features / 10 (if n_features &lt;= 1000), where n_features is the number of selected features, and M = 100 otherwise.</code></pre>
<pre><code>## Parameter k was not provided, will use k = sqrt(number_of_cells)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">indexCell</span>(muraro)</code></pre></div>
<pre><code>## Parameter M was not provided, will use M = n_features / 10 (if n_features &lt;= 1000), where n_features is the number of selected features, and M = 100 otherwise.
## Parameter k was not provided, will use k = sqrt(number_of_cells)</code></pre>
<p>In this case the index is a series of clusterings of each cell using different sets of features, parameters k and M are the number of clusters and the number of features used in each of these subclusterings. New cells are assigned to the nearest cluster in each subclustering to generate unique pattern of cluster assignments. We then find the cell in the reference dataset with the same or most similar pattern of cluster assignments.</p>
<p>We can examine the cluster assignment patterns for the reference datasets using:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">metadata</span>(muraro)<span class="op">$</span>scmap_cell_index<span class="op">$</span>subclusters[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<pre><code>##      D28.1_1 D28.1_13 D28.1_15 D28.1_17 D28.1_2
## [1,]       4       42       27       43      10
## [2,]       5        8        2       33      37
## [3,]      11       32       35       17      26
## [4,]       2        4       32        2      18
## [5,]      31       18       21       40       1</code></pre>
<p>To project and find the <code>w</code> nearest neighbours we use a similar command as before:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro_to_seger &lt;-<span class="st"> </span><span class="kw">scmapCell</span>(
  <span class="dt">projection =</span> muraro,
  <span class="dt">index_list =</span> <span class="kw">list</span>(
    <span class="dt">seger =</span> <span class="kw">metadata</span>(segerstolpe)<span class="op">$</span>scmap_cell_index
  ),
  <span class="dt">w =</span> <span class="dv">5</span>
)</code></pre></div>
<p>We can again look at the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro_to_seger<span class="op">$</span>seger[[<span class="dv">1</span>]][,<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<pre><code>##      D28.1_1 D28.1_13 D28.1_15 D28.1_17 D28.1_2
## [1,]    2201     1288     1117     1623    1078
## [2,]    1229     1724     2104     1448    1593
## [3,]    1793     1854     2201     2039    1553
## [4,]    1882     1737     1081     1202    1890
## [5,]    1731      976     1903     1834    1437</code></pre>
<p>This shows the column number of the 5 nearest neighbours in segerstolpe to each of the cells in muraro. We could then calculate a pseudotime estimate, branch assignment, or other cell-level data by selecting the appropriate data from the colData of the segerstolpe data set. As a demonstration we will find the cell-type of the nearest neighbour of each cell.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cell_type_NN &lt;-<span class="st"> </span><span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1[muraro_to_seger<span class="op">$</span>seger[[<span class="dv">1</span>]][<span class="dv">1</span>,]]
<span class="kw">head</span>(cell_type_NN)</code></pre></div>
<pre><code>## [1] &quot;alpha&quot;       &quot;ductal&quot;      &quot;alpha&quot;       &quot;alpha&quot;       &quot;endothelial&quot;
## [6] &quot;endothelial&quot;</code></pre>
</div>
<div id="metaneighbour" class="section level3">
<h3><span class="header-section-number">8.8.5</span> Metaneighbour</h3>
<p><a href="https://www.biorxiv.org/content/early/2017/06/16/150524">Metaneighbour</a> is specifically designed to ask whether cell-type labels are consistent across datasets. It comes in two versions. First is a fully supervised method which assumes cell-types are known in all datasets and calculates how “good” those cell-type labels are. (The precise meaning of “good” will be described below). Alternatively, metaneighbour can estimate how similar all cell-types are to each other both within and across datasets. We will only be using the unsupervised version as it has much more general applicability and is easier to interpret the results of.</p>
<p>Metaneighbour compares cell-types across datasets by building a cell-cell spearman correlation network. The method then tries to predict the label of each cell through weighted “votes” of its nearest-neighbours. Then scores the overall similarity between two clusters as the AUROC for assigning cells of typeA to typeB based on these weighted votes. AUROC of 1 would indicate all the cells of typeA were assigned to typeB before any other cells were, and an AUROC of 0.5 is what you would get if cells were being randomly assigned.</p>
<p>Metanighbour is just a couple of R functions not a complete package so we have to load them using <code>source</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">source</span>(<span class="st">&quot;2017-08-28-runMN-US.R&quot;</span>)</code></pre></div>
<div id="prepare-data" class="section level4">
<h4><span class="header-section-number">8.8.5.1</span> Prepare Data</h4>
<p>Metaneighbour requires all datasets to be combined into a single expression matrix prior to running:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">is.common &lt;-<span class="st"> </span><span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol <span class="op">%in%</span><span class="st"> </span><span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol
muraro &lt;-<span class="st"> </span>muraro[is.common,]
segerstolpe &lt;-<span class="st"> </span>segerstolpe[<span class="kw">match</span>(<span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol, <span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol),]
<span class="kw">rownames</span>(segerstolpe) &lt;-<span class="st"> </span><span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol
<span class="kw">rownames</span>(muraro) &lt;-<span class="st"> </span><span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol
<span class="kw">identical</span>(<span class="kw">rownames</span>(segerstolpe), <span class="kw">rownames</span>(muraro))</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">combined_logcounts &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">logcounts</span>(muraro), <span class="kw">logcounts</span>(segerstolpe))
dataset_labels &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;s&quot;</span>), <span class="dt">times=</span><span class="kw">c</span>(<span class="kw">ncol</span>(muraro), <span class="kw">ncol</span>(segerstolpe)))
cell_type_labels &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1, <span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1)

pheno &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Sample_ID =</span> <span class="kw">colnames</span>(combined_logcounts),
                <span class="dt">Study_ID=</span>dataset_labels,
                <span class="dt">Celltype=</span><span class="kw">paste</span>(cell_type_labels, dataset_labels, <span class="dt">sep=</span><span class="st">&quot;-&quot;</span>))
<span class="kw">rownames</span>(pheno) &lt;-<span class="st"> </span><span class="kw">colnames</span>(combined_logcounts)</code></pre></div>
<p>Metaneighbor includes a feature selection method to identify highly variable genes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">var.genes =<span class="st"> </span><span class="kw">get_variable_genes</span>(combined_logcounts, pheno)</code></pre></div>
<p>Since Metaneighbor is much slower than <code>scmap</code>, we will down sample these datasets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subset &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(pheno), <span class="dv">2000</span>)
combined_logcounts &lt;-<span class="st"> </span>combined_logcounts[,subset]
pheno &lt;-<span class="st"> </span>pheno[subset,]
cell_type_labels &lt;-<span class="st"> </span>cell_type_labels[subset]
dataset_labels &lt;-<span class="st"> </span>dataset_labels[subset]</code></pre></div>
<p>Now we are ready to run Metaneighbor. First we will run the unsupervised version that will let us see which cell-types are most similar across the two datasets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">unsup &lt;-<span class="st"> </span><span class="kw">run_MetaNeighbor_US</span>(var.genes, combined_logcounts, <span class="kw">unique</span>(pheno<span class="op">$</span>Celltype), pheno)
<span class="kw">heatmap</span>(unsup)</code></pre></div>
<p><img src="31-projection_files/figure-html/unnamed-chunk-32-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="mnncorrect-1" class="section level3">
<h3><span class="header-section-number">8.8.6</span> mnnCorrect</h3>
<p><a href="https://www.biorxiv.org/content/early/2017/07/18/165118">mnnCorrect</a> corrects datasets to facilitate joint analysis. It order to account for differences in composition between two replicates or two different experiments it first matches invidual cells across experiments to find the overlaping biologicial structure. Using that overlap it learns which dimensions of expression correspond to the biological state and which dimensions correspond to batch/experiment effect; mnnCorrect assumes these dimensions are orthologal to each other in high dimensional expression space. Finally it removes the batch/experiment effects from the entire expression matrix to return the corrected matrix.</p>
<p>To match individual cells to each other across datasets, mnnCorrect uses the cosine distance to avoid library-size effect then identifies mututal nearest neighbours (<code>k</code> determines to neighbourhood size) across datasets. Only overlaping biological groups should have mutual nearest neighbours (see panel b below). However, this assumes that k is set to approximately the size of the smallest biological group in the datasets, but a k that is too low will identify too few mutual nearest-neighbour pairs to get a good estimate of the batch effect we want to remove.</p>
<p>Learning the biological/techncial effects is done with either singular value decomposition, similar to RUV we encounters in the batch-correction section, or with principal component analysis with the opitimized irlba package, which should be faster than SVD. The parameter <code>svd.dim</code> specifies how many dimensions should be kept to summarize the biological structure of the data, we will set it to three as we found three major groups using Metaneighbor above. These estimates may be futher adjusted by smoothing (<code>sigma</code>) and/or variance adjustment (<code>var.adj</code>).</p>
<p>mnnCorrect also assumes you’ve already subset your expression matricies so that they contain identical genes in the same order, fortunately we have already done with for our datasets when we set up our data for Metaneighbor.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-33"></span>
<img src="figures/mnnCorrectDiagramCropped.png" alt="mnnCorrect batch/dataset effect correction. From Haghverdi et al. 2017"  />
<p class="caption">
Figure 8.21: mnnCorrect batch/dataset effect correction. From Haghverdi et al. 2017
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;scran&quot;</span>)</code></pre></div>
<pre><code>## Loading required package: scran</code></pre>
<pre><code>## Loading required package: BiocParallel</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># mnnCorrect will take several minutes to run</span>
corrected &lt;-<span class="st"> </span><span class="kw">mnnCorrect</span>(<span class="kw">logcounts</span>(muraro), <span class="kw">logcounts</span>(segerstolpe), <span class="dt">k=</span><span class="dv">20</span>, <span class="dt">sigma=</span><span class="dv">1</span>, <span class="dt">pc.approx=</span><span class="ot">TRUE</span>, <span class="dt">subset.row=</span>var.genes, <span class="dt">svd.dim=</span><span class="dv">3</span>)</code></pre></div>
<p>First let’s check that we found a sufficient number of mnn pairs, mnnCorrect returns a list of dataframe with the mnn pairs for each dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(corrected<span class="op">$</span>pairs[[<span class="dv">1</span>]]) <span class="co"># muraro -&gt; others</span></code></pre></div>
<pre><code>## [1] 0 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(corrected<span class="op">$</span>pairs[[<span class="dv">2</span>]]) <span class="co"># seger -&gt; others</span></code></pre></div>
<pre><code>## [1] 2533    3</code></pre>
<p>The first and second columns contain the cell column IDs and the third column contains a number indicating which dataset/batch the column 2 cell belongs to. In our case, we are only comparing two datasets so all the mnn pairs have been assigned to the second table and the third column contains only ones</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(corrected<span class="op">$</span>pairs[[<span class="dv">2</span>]])</code></pre></div>
<pre><code>## DataFrame with 6 rows and 3 columns
##   current.cell other.cell other.batch
##      &lt;integer&gt;      &lt;Rle&gt;       &lt;Rle&gt;
## 1         1553          5           1
## 2         1078          5           1
## 3         1437          5           1
## 4         1890          5           1
## 5         1569          5           1
## 6          373          5           1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">total_pairs &lt;-<span class="st"> </span><span class="kw">nrow</span>(corrected<span class="op">$</span>pairs[[<span class="dv">2</span>]])
n_unique_seger &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>((corrected<span class="op">$</span>pairs[[<span class="dv">2</span>]][,<span class="dv">1</span>])))
n_unique_muraro &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>((corrected<span class="op">$</span>pairs[[<span class="dv">2</span>]][,<span class="dv">2</span>])))</code></pre></div>
<p>mnnCorrect found 2533 sets of mutual nearest-neighbours between <code>n_unique_seger</code> segerstolpe cells and <code>n_unique_muraro</code> muraro cells. This should be a sufficient number of pairs but the low number of unique cells in each dataset suggests we might not have captured the full biological signal in each dataset.</p>
<p><strong>Exercise</strong> Which cell-types had mnns across these datasets? Should we increase/decrease k?</p>
<p><strong>Answer</strong></p>
<p>Now we could create a combined dataset to jointly analyse these data. However, the corrected data is no longer counts and usually will contain negative expression values thus some analysis tools may no longer be appropriate. For simplicity let’s just plot a joint TSNE.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;Rtsne&quot;</span>)</code></pre></div>
<pre><code>## Loading required package: Rtsne</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">joint_expression_matrix &lt;-<span class="st"> </span><span class="kw">cbind</span>(corrected<span class="op">$</span>corrected[[<span class="dv">1</span>]], corrected<span class="op">$</span>corrected[[<span class="dv">2</span>]])

<span class="co"># Tsne will take some time to run on the full dataset</span>
joint_tsne &lt;-<span class="st"> </span><span class="kw">Rtsne</span>(<span class="kw">t</span>(joint_expression_matrix[<span class="kw">rownames</span>(joint_expression_matrix) <span class="op">%in%</span><span class="st"> </span>var.genes,]), <span class="dt">initial_dims=</span><span class="dv">10</span>, <span class="dt">theta=</span><span class="fl">0.75</span>,
                        <span class="dt">check_duplicates=</span><span class="ot">FALSE</span>, <span class="dt">max_iter=</span><span class="dv">200</span>, <span class="dt">stop_lying_iter=</span><span class="dv">50</span>, <span class="dt">mom_switch_iter=</span><span class="dv">50</span>)
dataset_labels &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;s&quot;</span>), <span class="dt">times=</span><span class="kw">c</span>(<span class="kw">ncol</span>(muraro), <span class="kw">ncol</span>(segerstolpe))))
cell_type_labels &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1, <span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1))
<span class="kw">plot</span>(joint_tsne<span class="op">$</span>Y[,<span class="dv">1</span>], joint_tsne<span class="op">$</span>Y[,<span class="dv">2</span>], <span class="dt">pch=</span><span class="kw">c</span>(<span class="dv">16</span>,<span class="dv">1</span>)[dataset_labels], <span class="dt">col=</span><span class="kw">rainbow</span>(<span class="kw">length</span>(<span class="kw">levels</span>(cell_type_labels)))[cell_type_labels])</code></pre></div>
<p><img src="31-projection_files/figure-html/unnamed-chunk-38-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="cannonical-correlation-analysis-seurat" class="section level3">
<h3><span class="header-section-number">8.8.7</span> Cannonical Correlation Analysis (Seurat)</h3>
<p>The Seurat package contains another correction method for combining multiple datasets, called <a href="https://www.biorxiv.org/content/early/2017/07/18/164889">CCA</a>. However, unlike mnnCorrect it doesn’t correct the expression matrix itself directly. Instead Seurat finds a lower dimensional subspace for each dataset then corrects these subspaces. Also different from mnnCorrect, Seurat only combines a single pair of datasets at a time.</p>
<p>Seurat uses gene-gene correlations to identify the biological structure in the dataset with a method called canonical correlation analysis (CCA). Seurat learns the shared structure to the gene-gene correlations and then evaluates how well each cell fits this structure. Cells which must better described by a data-specific dimensionality reduction method than by the shared correlation structure are assumed to represent dataset-specific cell-types/states and are discarded before aligning the two datasets. Finally the two datasets are aligned using ‘warping’ algorithms which normalize the low-dimensional representations of each dataset in a way that is robust to differences in population density.</p>
<p>Note because Seurat uses up a lot of library space you will have to restart your R-session to load it, and the plots/merged_seuratput won’t be automatically generated on this page.</p>
<p>Reload the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/muraro.rds&quot;</span>)
segerstolpe &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/segerstolpe.rds&quot;</span>)
segerstolpe &lt;-<span class="st"> </span>segerstolpe[,<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;unclassified&quot;</span>]
segerstolpe &lt;-<span class="st"> </span>segerstolpe[,<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;not applicable&quot;</span>,]
muraro &lt;-<span class="st"> </span>muraro[,<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1 <span class="op">!=</span><span class="st"> &quot;unclear&quot;</span>]
is.common &lt;-<span class="st"> </span><span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol <span class="op">%in%</span><span class="st"> </span><span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol
muraro &lt;-<span class="st"> </span>muraro[is.common,]
segerstolpe &lt;-<span class="st"> </span>segerstolpe[<span class="kw">match</span>(<span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol, <span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol),]
<span class="kw">rownames</span>(segerstolpe) &lt;-<span class="st"> </span><span class="kw">rowData</span>(segerstolpe)<span class="op">$</span>feature_symbol
<span class="kw">rownames</span>(muraro) &lt;-<span class="st"> </span><span class="kw">rowData</span>(muraro)<span class="op">$</span>feature_symbol
<span class="kw">identical</span>(<span class="kw">rownames</span>(segerstolpe), <span class="kw">rownames</span>(muraro))</code></pre></div>
<p>First we will reformat our data into Seurat objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;Seurat&quot;</span>)
<span class="kw">set.seed</span>(<span class="dv">4719364</span>)
muraro_seurat &lt;-<span class="st"> </span><span class="kw">CreateSeuratObject</span>(<span class="dt">raw.data=</span><span class="kw">assays</span>(muraro)[[<span class="st">&quot;normcounts&quot;</span>]]) <span class="co"># raw counts aren&#39;t available for muraro</span>
muraro_seurat<span class="op">@</span>meta.data[, <span class="st">&quot;dataset&quot;</span>] &lt;-<span class="st"> </span><span class="dv">1</span>
muraro_seurat<span class="op">@</span>meta.data[, <span class="st">&quot;celltype&quot;</span>] &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;m&quot;</span>,<span class="kw">colData</span>(muraro)<span class="op">$</span>cell_type1, <span class="dt">sep=</span><span class="st">&quot;-&quot;</span>)

seger_seurat &lt;-<span class="st"> </span><span class="kw">CreateSeuratObject</span>(<span class="dt">raw.data=</span><span class="kw">assays</span>(segerstolpe)[[<span class="st">&quot;counts&quot;</span>]])
seger_seurat<span class="op">@</span>meta.data[, <span class="st">&quot;dataset&quot;</span>] &lt;-<span class="st"> </span><span class="dv">2</span>
seger_seurat<span class="op">@</span>meta.data[, <span class="st">&quot;celltype&quot;</span>] &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;s&quot;</span>,<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1, <span class="dt">sep=</span><span class="st">&quot;-&quot;</span>)</code></pre></div>
<p>Next we must normalize, scale and identify highly variable genes for each dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro_seurat &lt;-<span class="st"> </span><span class="kw">NormalizeData</span>(<span class="dt">object=</span>muraro_seurat)
muraro_seurat &lt;-<span class="st"> </span><span class="kw">ScaleData</span>(<span class="dt">object=</span>muraro_seurat)
muraro_seurat &lt;-<span class="st"> </span><span class="kw">FindVariableGenes</span>(<span class="dt">object=</span>muraro_seurat, <span class="dt">do.plot=</span><span class="ot">TRUE</span>)

seger_seurat &lt;-<span class="st"> </span><span class="kw">NormalizeData</span>(<span class="dt">object=</span>seger_seurat)
seger_seurat &lt;-<span class="st"> </span><span class="kw">ScaleData</span>(<span class="dt">object=</span>seger_seurat)
seger_seurat &lt;-<span class="st"> </span><span class="kw">FindVariableGenes</span>(<span class="dt">object=</span>seger_seurat, <span class="dt">do.plot=</span><span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-42"></span>
<img src="figures/muraro_seurat_hvg.png" alt="muraro variable genes"  />
<p class="caption">
Figure 8.22: muraro variable genes
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-43"></span>
<img src="figures/seger_seurat_hvg.png" alt="segerstolpe variable genes"  />
<p class="caption">
Figure 8.23: segerstolpe variable genes
</p>
</div>
<p>Eventhough Seurat corrects for the relationship between dispersion and mean expression, it doesn’t use the corrected value when ranking features. Compare the results of the command below with the results in the plots above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(muraro_seurat<span class="op">@</span>hvg.info, <span class="dv">50</span>)
<span class="kw">head</span>(seger_seurat<span class="op">@</span>hvg.info, <span class="dv">50</span>)</code></pre></div>
<p>But we will follow their example and use the top 2000 most dispersed genes withmerged_seurat correcting for mean expression from each dataset anyway.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gene.use &lt;-<span class="st"> </span><span class="kw">union</span>(<span class="kw">rownames</span>(<span class="dt">x =</span> <span class="kw">head</span>(<span class="dt">x =</span> muraro_seurat<span class="op">@</span>hvg.info, <span class="dt">n =</span> <span class="dv">2000</span>)),
                  <span class="kw">rownames</span>(<span class="dt">x =</span> <span class="kw">head</span>(<span class="dt">x =</span> seger_seurat<span class="op">@</span>hvg.info, <span class="dt">n =</span> <span class="dv">2000</span>)))</code></pre></div>
<p><strong>Exercise</strong> Find the features we would use if we selected the top 2000 most dispersed after scaling by mean. (Hint: consider the <code>order</code> function)</p>
<p><strong>Answer</strong></p>
<p>Now we will run CCA to find the shared correlation structure for these two datasets:</p>
<p>Note to speed up the calculations we will be using only the top 5 dimensions but ideally you would consider many more and then select the top most informative ones using <code>DimHeatmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">merged_seurat &lt;-<span class="st"> </span><span class="kw">RunCCA</span>(<span class="dt">object=</span>muraro_seurat, <span class="dt">object2=</span>seger_seurat, <span class="dt">genes.use=</span>gene.use, <span class="dt">add.cell.id1=</span><span class="st">&quot;m&quot;</span>, <span class="dt">add.cell.id2=</span><span class="st">&quot;s&quot;</span>, <span class="dt">num.cc =</span> <span class="dv">5</span>)
<span class="kw">DimPlot</span>(<span class="dt">object =</span> merged_seurat, <span class="dt">reduction.use =</span> <span class="st">&quot;cca&quot;</span>, <span class="dt">group.by =</span> <span class="st">&quot;dataset&quot;</span>, <span class="dt">pt.size =</span> <span class="fl">0.5</span>) <span class="co"># Before correcting</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-48"></span>
<img src="figures/cca_before.png" alt="Before Aligning"  />
<p class="caption">
Figure 8.24: Before Aligning
</p>
</div>
<p>To identify dataset specific cell-types we compare how well cells are ‘explained’ by CCA vs dataset-specific principal component analysis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">merged_seurat &lt;-<span class="st"> </span><span class="kw">CalcVarExpRatio</span>(<span class="dt">object =</span> merged_seurat, <span class="dt">reduction.type =</span> <span class="st">&quot;pca&quot;</span>, <span class="dt">grouping.var =</span> <span class="st">&quot;dataset&quot;</span>, <span class="dt">dims.use =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
merged.all &lt;-<span class="st"> </span>merged_seurat
merged_seurat &lt;-<span class="st"> </span><span class="kw">SubsetData</span>(<span class="dt">object=</span>merged_seurat, <span class="dt">subset.name=</span><span class="st">&quot;var.ratio.pca&quot;</span>, <span class="dt">accept.low =</span> <span class="fl">0.5</span>) <span class="co"># CCA &gt; 1/2 as good as PCA</span>
merged.discard &lt;-<span class="st"> </span><span class="kw">SubsetData</span>(<span class="dt">object=</span>merged.all, <span class="dt">subset.name=</span><span class="st">&quot;var.ratio.pca&quot;</span>, <span class="dt">accept.high =</span> <span class="fl">0.5</span>)

<span class="kw">summary</span>(<span class="kw">factor</span>(merged.discard<span class="op">@</span>meta.data<span class="op">$</span>celltype)) <span class="co"># check the cell-type of the discarded cells.</span></code></pre></div>
<p>Here we can see that despite both datasets containing endothelial cells, almost all of them have been discarded as “dataset-specific”. Now we can align the datasets:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">merged_seurat &lt;-<span class="st"> </span><span class="kw">AlignSubspace</span>(<span class="dt">object =</span> merged_seurat, <span class="dt">reduction.type =</span> <span class="st">&quot;cca&quot;</span>, <span class="dt">grouping.var =</span> <span class="st">&quot;dataset&quot;</span>, <span class="dt">dims.align =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
<span class="kw">DimPlot</span>(<span class="dt">object =</span> merged_seurat, <span class="dt">reduction.use =</span> <span class="st">&quot;cca.aligned&quot;</span>, <span class="dt">group.by =</span> <span class="st">&quot;dataset&quot;</span>, <span class="dt">pt.size =</span> <span class="fl">0.5</span>) <span class="co"># After aligning subspaces</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-51"></span>
<img src="figures/cca_after.png" alt="After Aligning"  />
<p class="caption">
Figure 8.25: After Aligning
</p>
</div>
<p><strong>Exercise</strong> Compare the results for if you use the features after scaling dispersions.</p>
<p><strong>Answer</strong></p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-53"></span>
<img src="figures/cca_after2.png" alt="After Aligning"  />
<p class="caption">
Figure 8.26: After Aligning
</p>
</div>
<p><strong>Advanced Exercise</strong> Use the clustering methods we previously covered on the combined datasets. Do you identify any novel cell-types?</p>
</div>
<div id="sessioninfo-10" class="section level3">
<h3><span class="header-section-number">8.8.8</span> sessionInfo()</h3>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] Rtsne_0.13                 scran_1.6.8               
##  [3] BiocParallel_1.12.0        bindrcpp_0.2              
##  [5] scmap_1.1.5                scater_1.6.3              
##  [7] SingleCellExperiment_1.0.0 SummarizedExperiment_1.8.1
##  [9] DelayedArray_0.4.1         matrixStats_0.53.1        
## [11] GenomicRanges_1.30.3       GenomeInfoDb_1.14.0       
## [13] IRanges_2.12.0             S4Vectors_0.16.0          
## [15] ggplot2_2.2.1              Biobase_2.38.0            
## [17] BiocGenerics_0.24.0        googleVis_0.6.2           
## [19] knitr_1.20                
## 
## loaded via a namespace (and not attached):
##  [1] bitops_1.0-6           bit64_0.9-7            progress_1.1.2        
##  [4] httr_1.3.1             rprojroot_1.3-2        dynamicTreeCut_1.63-1 
##  [7] tools_3.4.3            backports_1.1.2        irlba_2.3.2           
## [10] DT_0.4                 R6_2.2.2               vipor_0.4.5           
## [13] DBI_0.7                lazyeval_0.2.1         colorspace_1.3-2      
## [16] gridExtra_2.3          prettyunits_1.0.2      bit_1.1-12            
## [19] compiler_3.4.3         labeling_0.3           bookdown_0.7          
## [22] scales_0.5.0           randomForest_4.6-12    proxy_0.4-21          
## [25] stringr_1.3.0          digest_0.6.15          rmarkdown_1.8         
## [28] XVector_0.18.0         pkgconfig_2.0.1        htmltools_0.3.6       
## [31] limma_3.34.9           highr_0.6              htmlwidgets_1.0       
## [34] rlang_0.2.0            RSQLite_2.0            FNN_1.1               
## [37] shiny_1.0.5            bindr_0.1              zoo_1.8-1             
## [40] jsonlite_1.5           dplyr_0.7.4            RCurl_1.95-4.10       
## [43] magrittr_1.5           GenomeInfoDbData_1.0.0 Matrix_1.2-7.1        
## [46] Rcpp_0.12.15           ggbeeswarm_0.6.0       munsell_0.4.3         
## [49] viridis_0.5.0          stringi_1.1.6          yaml_2.1.17           
## [52] edgeR_3.20.9           zlibbioc_1.24.0        rhdf5_2.22.0          
## [55] plyr_1.8.4             grid_3.4.3             blob_1.1.0            
## [58] shinydashboard_0.6.1   lattice_0.20-34        locfit_1.5-9.1        
## [61] pillar_1.2.1           igraph_1.1.2           rjson_0.2.15          
## [64] reshape2_1.4.3         codetools_0.2-15       biomaRt_2.34.2        
## [67] XML_3.98-1.10          glue_1.2.0             evaluate_0.10.1       
## [70] data.table_1.10.4-3    httpuv_1.3.6.1         gtable_0.2.0          
## [73] assertthat_0.2.0       xfun_0.1               mime_0.5              
## [76] xtable_1.8-2           e1071_1.6-8            class_7.3-14          
## [79] viridisLite_0.3.0      tibble_1.4.2           AnnotationDbi_1.40.0  
## [82] beeswarm_0.2.3         memoise_1.1.0          tximport_1.6.0        
## [85] statmod_1.4.30</code></pre>

</div>
</div>
<div id="search-scrna-seq-data" class="section level2">
<h2><span class="header-section-number">8.9</span> Search scRNA-Seq data</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scfind)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<div id="about" class="section level3">
<h3><span class="header-section-number">8.9.1</span> About</h3>
<p><code>scfind</code> is a tool that allows one to search single cell RNA-Seq collections (Atlas) using lists of genes, e.g. searching for cells and cell-types where a specific set of genes are expressed. <code>scfind</code> is a <a href="http://bioconductor.org/packages/scfind">Bioconductor package</a>. Cloud implementation of <code>scfind</code> with a large collection of datasets is available on our <a href="http://www.hemberg-lab.cloud/scfind">website</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-3"></span>
<img src="figures/scfind.png" alt="scfind can be used to search large collection of scRNA-seq data by a list of gene IDs." width="80%" />
<p class="caption">
Figure 2.4: scfind can be used to search large collection of scRNA-seq data by a list of gene IDs.
</p>
</div>
</div>
<div id="dataset" class="section level3">
<h3><span class="header-section-number">8.9.2</span> Dataset</h3>
<p>We will run <code>scfind</code> on the same human pancreas dataset as in the previous chapter. <code>scfind</code> also operates on <code>SingleCellExperiment</code> class:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/muraro.rds&quot;</span>)</code></pre></div>
</div>
<div id="gene-index" class="section level3">
<h3><span class="header-section-number">8.9.3</span> Gene Index</h3>
<p>Now we need to create a gene index using our dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cellIndex &lt;-<span class="st"> </span><span class="kw">buildCellIndex</span>(muraro)</code></pre></div>
<p>The gene index contains for each gene indexes of the cells where it is expressed. This is similar to sparsification of the expression matrix. In addition to this the index is also compressed in a way that it can accessed very quickly. We estimated that one can achieve 5-10 compression factor with this method.</p>
<p>By default the <code>cell_type1</code> column of the <code>colData</code> slot of the <code>SingleCellExperiment</code> object is used to define cell types, however it can also be defined manually using the <code>cell_type_column</code> argument of the <code>buildCellTypeIndex</code> function (check <code>?buildCellTypeIndex</code>).</p>
</div>
<div id="marker-genes" class="section level3">
<h3><span class="header-section-number">8.9.4</span> Marker genes</h3>
<p>Now let’s define lists of cell type specific marker genes. We will use the marker genes identified in the original publication, namely in Figure 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># these genes are taken from fig. 1</span>
muraro_alpha &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;GCG&quot;</span>, <span class="st">&quot;LOXL4&quot;</span>, <span class="st">&quot;PLCE1&quot;</span>, <span class="st">&quot;IRX2&quot;</span>, <span class="st">&quot;GC&quot;</span>, <span class="st">&quot;KLHL41&quot;</span>, 
                  <span class="st">&quot;CRYBA2&quot;</span>, <span class="st">&quot;TTR&quot;</span>, <span class="st">&quot;TM4SF4&quot;</span>, <span class="st">&quot;RGS4&quot;</span>)
muraro_beta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;INS&quot;</span>, <span class="st">&quot;IAPP&quot;</span>, <span class="st">&quot;MAFA&quot;</span>, <span class="st">&quot;NPTX2&quot;</span>, <span class="st">&quot;DLK1&quot;</span>, <span class="st">&quot;ADCYAP1&quot;</span>, 
                 <span class="st">&quot;PFKFB2&quot;</span>, <span class="st">&quot;PDX1&quot;</span>, <span class="st">&quot;TGFBR3&quot;</span>, <span class="st">&quot;SYT13&quot;</span>)
muraro_gamma &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;PPY&quot;</span>, <span class="st">&quot;SERTM1&quot;</span>, <span class="st">&quot;CARTPT&quot;</span>, <span class="st">&quot;SLITRK6&quot;</span>, <span class="st">&quot;ETV1&quot;</span>, 
                  <span class="st">&quot;THSD7A&quot;</span>, <span class="st">&quot;AQP3&quot;</span>, <span class="st">&quot;ENTPD2&quot;</span>, <span class="st">&quot;PTGFR&quot;</span>, <span class="st">&quot;CHN2&quot;</span>)
muraro_delta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;SST&quot;</span>, <span class="st">&quot;PRG4&quot;</span>, <span class="st">&quot;LEPR&quot;</span>, <span class="st">&quot;RBP4&quot;</span>, <span class="st">&quot;BCHE&quot;</span>, <span class="st">&quot;HHEX&quot;</span>, 
                  <span class="st">&quot;FRZB&quot;</span>, <span class="st">&quot;PCSK1&quot;</span>, <span class="st">&quot;RGS2&quot;</span>, <span class="st">&quot;GABRG2&quot;</span>)</code></pre></div>
</div>
<div id="search-cells-by-a-gene-list" class="section level3">
<h3><span class="header-section-number">8.9.5</span> Search cells by a gene list</h3>
<p><code>findCell</code> function returns a list of p-values corresponding to all cell types in a given dataset. It also outputs a list of cells in which genes from the given gene list are co-expressed. We will run it on all lists of marker genes defined above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">findCell</span>(cellIndex, muraro_alpha)
<span class="kw">barplot</span>(<span class="op">-</span><span class="kw">log10</span>(res<span class="op">$</span>p_values), <span class="dt">ylab =</span> <span class="st">&quot;-log10(pval)&quot;</span>, <span class="dt">las =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="32-search_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(res<span class="op">$</span>common_exprs_cells)</code></pre></div>
<pre><code>##   cell_id cell_type
## 1       1     alpha
## 2       3     alpha
## 3       7     alpha
## 4       9     alpha
## 5      15     alpha
## 6      20     alpha</code></pre>
<p><strong>Exercise 1</strong></p>
<p>Perform a search by <em>beta</em>, <em>delta</em> and <em>gamma</em> gene lists and explore the results.</p>
<p><img src="32-search_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      71     alpha
## 2      72      beta
## 3      92      beta
## 4      96      beta
## 5      98      beta
## 6     102      beta</code></pre>
<p><img src="32-search_files/figure-html/unnamed-chunk-8-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      40     delta
## 2     212     delta
## 3     225     delta
## 4     253     delta
## 5     330     delta
## 6     400     delta</code></pre>
<p><img src="32-search_files/figure-html/unnamed-chunk-8-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      53     alpha
## 2     102      beta
## 3     255     gamma
## 4     305     gamma
## 5     525     gamma
## 6     662     gamma</code></pre>
<p><strong>Exercise 2</strong></p>
<p>Load the <code>segerstolpe</code> and search it using <em>alpha</em>, <em>beta</em>, <em>delta</em> and <em>gamma</em> gene lists identified in <code>muraro</code> dataset.</p>
<p><img src="32-search_files/figure-html/unnamed-chunk-9-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      18     alpha
## 2      20     alpha
## 3      24     alpha
## 4      32     alpha
## 5      43     alpha
## 6      48     alpha</code></pre>
<p><img src="32-search_files/figure-html/unnamed-chunk-9-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id     cell_type
## 1      15 co-expression
## 2      58          beta
## 3     300          beta
## 4     390 co-expression
## 5     504 co-expression
## 6     506          beta</code></pre>
<p><img src="32-search_files/figure-html/unnamed-chunk-9-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id     cell_type
## 1     170         delta
## 2     715         delta
## 3    1039 co-expression
## 4    1133         delta
## 5    1719         delta
## 6    1721         delta</code></pre>
<p><img src="32-search_files/figure-html/unnamed-chunk-9-4.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      47     gamma
## 2     458     gamma
## 3     476     gamma
## 4     600     gamma
## 5     606     gamma
## 6     622     gamma</code></pre>
</div>
<div id="sessioninfo-11" class="section level3">
<h3><span class="header-section-number">8.9.6</span> sessionInfo()</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sessionInfo</span>()</code></pre></div>
<pre><code>## R version 3.4.3 (2017-11-30)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS: /usr/lib/openblas-base/libblas.so.3
## LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] SingleCellExperiment_1.0.0 SummarizedExperiment_1.8.1
##  [3] DelayedArray_0.4.1         matrixStats_0.53.1        
##  [5] Biobase_2.38.0             GenomicRanges_1.30.3      
##  [7] GenomeInfoDb_1.14.0        IRanges_2.12.0            
##  [9] S4Vectors_0.16.0           BiocGenerics_0.24.0       
## [11] scfind_1.0.0               knitr_1.20                
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.15           highr_0.6              plyr_1.8.4            
##  [4] pillar_1.2.1           compiler_3.4.3         XVector_0.18.0        
##  [7] bindr_0.1              bitops_1.0-6           tools_3.4.3           
## [10] zlibbioc_1.24.0        digest_0.6.15          bit_1.1-12            
## [13] tibble_1.4.2           evaluate_0.10.1        lattice_0.20-34       
## [16] pkgconfig_2.0.1        rlang_0.2.0            Matrix_1.2-7.1        
## [19] yaml_2.1.17            xfun_0.1               bindrcpp_0.2          
## [22] GenomeInfoDbData_1.0.0 stringr_1.3.0          dplyr_0.7.4           
## [25] rprojroot_1.3-2        grid_3.4.3             glue_1.2.0            
## [28] R6_2.2.2               hash_2.2.6             rmarkdown_1.8         
## [31] bookdown_0.7           reshape2_1.4.3         magrittr_1.5          
## [34] backports_1.1.2        htmltools_0.3.6        assertthat_0.2.0      
## [37] stringi_1.1.6          RCurl_1.95-4.10</code></pre>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
</div>
</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-Guo2015-ok">
<p>Guo, Minzhe, Hui Wang, S. Steven Potter, Jeffrey A. Whitsett, and Yan Xu. 2015. “SINCERA: A Pipeline for Single-Cell RNA-Seq Profiling Analysis.” <em>PLoS Comput Biol</em> 11 (11). Public Library of Science (PLoS): e1004575. doi:<a href="https://doi.org/10.1371/journal.pcbi.1004575">10.1371/journal.pcbi.1004575</a>.</p>
</div>
<div id="ref-Zurauskiene2016-kg">
<p>žurauskienė, Justina, and Christopher Yau. 2016. “pcaReduce: Hierarchical Clustering of Single Cell Transcriptional Profiles.” <em>BMC Bioinformatics</em> 17 (1). Springer Nature. doi:<a href="https://doi.org/10.1186/s12859-016-0984-y">10.1186/s12859-016-0984-y</a>.</p>
</div>
<div id="ref-Kiselev2016-bq">
<p>Kiselev, Vladimir Yu, Kristina Kirschner, Michael T Schaub, Tallulah Andrews, Andrew Yiu, Tamir Chandra, Kedar N Natarajan, et al. 2017. “SC3: Consensus Clustering of Single-Cell RNA-Seq Data.” <em>Nat Meth</em> 14 (5). Springer Nature: 483–86. doi:<a href="https://doi.org/10.1038/nmeth.4236">10.1038/nmeth.4236</a>.</p>
</div>
<div id="ref-Xu2015-vf">
<p>Xu, Chen, and Zhengchang Su. 2015. “Identification of Cell Types from Single-Cell Transcriptomes Using a Novel Clustering Method.” <em>Bioinformatics</em> 31 (12). Oxford University Press (OUP): 1974–80. doi:<a href="https://doi.org/10.1093/bioinformatics/btv088">10.1093/bioinformatics/btv088</a>.</p>
</div>
<div id="ref-Levine2015-fk">
<p>Levine, Jacob H., Erin F. Simonds, Sean C. Bendall, Kara L. Davis, El-ad D. Amir, Michelle D. Tadmor, Oren Litvin, et al. 2015. “Data-Driven Phenotypic Dissection of AML Reveals Progenitor-Like Cells That Correlate with Prognosis.” <em>Cell</em> 162 (1). Elsevier BV: 184–97. doi:<a href="https://doi.org/10.1016/j.cell.2015.05.047">10.1016/j.cell.2015.05.047</a>.</p>
</div>
<div id="ref-Deng2014-mx">
<p>Deng, Q., D. Ramskold, B. Reinius, and R. Sandberg. 2014. “Single-Cell RNA-Seq Reveals Dynamic, Random Monoallelic Gene Expression in Mammalian Cells.” <em>Science</em> 343 (6167). American Association for the Advancement of Science (AAAS): 193–96. doi:<a href="https://doi.org/10.1126/science.1245316">10.1126/science.1245316</a>.</p>
</div>
<div id="ref-Cannoodt2016-uj">
<p>Cannoodt, Robrecht, Wouter Saelens, and Yvan Saeys. 2016. “Computational Methods for Trajectory Inference from Single-Cell Transcriptomics.” <em>Eur. J. Immunol.</em> 46 (11). Wiley-Blackwell: 2496–2506. doi:<a href="https://doi.org/10.1002/eji.201646347">10.1002/eji.201646347</a>.</p>
</div>
<div id="ref-Welch2016-jr">
<p>Welch, Joshua D., Alexander J. Hartemink, and Jan F. Prins. 2016. “SLICER: Inferring Branched, Nonlinear Cellular Trajectories from Single Cell RNA-Seq Data.” <em>Genome Biol</em> 17 (1). Springer Nature. doi:<a href="https://doi.org/10.1186/s13059-016-0975-3">10.1186/s13059-016-0975-3</a>.</p>
</div>
<div id="ref-Van_Dijk2017-bh">
<p>Dijk, David van, Juozas Nainys, Roshan Sharma, Pooja Kathail, Ambrose J Carr, Kevin R Moon, Linas Mazutis, Guy Wolf, Smita Krishnaswamy, and Dana Pe’er. 2017. “MAGIC: A Diffusion-Based Imputation Method Reveals Gene-Gene Interactions in Single-Cell RNA-sequencing Data.” <em>bioRxiv</em>, February, 111591.</p>
</div>
<div id="ref-Li2017-tz">
<p>Li, Wei Vivian, and Jingyi Jessica Li. 2017. “scImpute: Accurate and Robust Imputation for Single Cell RNA-Seq Data.” <em>bioRxiv</em>, June, 141598.</p>
</div>
<div id="ref-Regev2017-mw">
<p>Regev, Aviv, Sarah Teichmann, Eric S Lander, Ido Amit, Christophe Benoist, Ewan Birney, Bernd Bodenmiller, et al. 2017. “The Human Cell Atlas.” <em>bioRxiv</em>, May, 121202.</p>
</div>
<div id="ref-Altschul1990-ts">
<p>Altschul, Stephen F., Warren Gish, Webb Miller, Eugene W. Myers, and David J. Lipman. 1990. “Basic Local Alignment Search Tool.” <em>Journal of Molecular Biology</em> 215 (3). Elsevier BV: 403–10. doi:<a href="https://doi.org/10.1016/s0022-2836(05)80360-2">10.1016/s0022-2836(05)80360-2</a>.</p>
</div>
<div id="ref-Muraro2016-yk">
<p>Muraro, Mauro J., Gitanjali Dharmadhikari, Dominic Grün, Nathalie Groen, Tim Dielen, Erik Jansen, Leon van Gurp, et al. 2016. “A Single-Cell Transcriptome Atlas of the Human Pancreas.” <em>Cell Systems</em> 3 (4). Elsevier BV: 385–394.e3. doi:<a href="https://doi.org/10.1016/j.cels.2016.09.002">10.1016/j.cels.2016.09.002</a>.</p>
</div>
<div id="ref-Segerstolpe2016-wc">
<p>Segerstolpe, Åsa, Athanasia Palasantza, Pernilla Eliasson, Eva-Marie Andersson, Anne-Christine Andréasson, Xiaoyan Sun, Simone Picelli, et al. 2016. “Single-Cell Transcriptome Profiling of Human Pancreatic Islets in Health and Type 2 Diabetes.” <em>Cell Metabolism</em> 24 (4). Elsevier BV: 593–607. doi:<a href="https://doi.org/10.1016/j.cmet.2016.08.020">10.1016/j.cmet.2016.08.020</a>.</p>
</div>
<div id="ref-Kiselev2017-nb">
<p>Kiselev, Vladimir Yu, and Martin Hemberg. 2017. “Scmap - a Tool for Unsupervised Projection of Single Cell RNA-seq Data.” <em>bioRxiv</em>, July, 150292.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="cleaning-the-expression-matrix.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="seurat-chapter.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["scRNA-seq-course.pdf"],
"toc": {
"collapse": "section"
},
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
